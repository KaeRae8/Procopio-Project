#=====================================================================
# standard.slag
#
# Slag standard library classes.
#
# v3.5.0 (2011.06.18)
#
# --------------------------------------------------------------------
#
# Copyright 2010 Plasmaworks LLC
#
# Licensed under the Apache License, Version 2.0 (the "License"); 
# you may not use this file except in compliance with the License. 
# You may obtain a copy of the License at 
#
#   http://www.apache.org/licenses/LICENSE-2.0 
#
# Unless required by applicable law or agreed to in writing, 
# software distributed under the License is distributed on an 
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
# either express or implied. See the License for the specific 
# language governing permissions and limitations under the License.
#
#=====================================================================

class WrongFileDisclaimer
  # Prints an error message if you try and compile and run just this
  # file.
  METHODS
    method init:
      # Default initializer.
      println( "standard.slag just contains library routines." )
endClass

requisite class NativeData : RequiresCleanup
  # A "black box" of system data.
  METHODS
    method clean_up: native

    method release: clean_up
endClass

requisite aspect ManagerCreates;
  # Initializer calls ("String(bytes)") to classes incorporating this
  # aspect are automatically remapped to the singleton manager
  # ("StringManager.create_from(bytes)").  Allows for conventional
  # syntax for objects that are created in a non-standard fashion.

requisite class WeakReference : ManagerCreates
  CLASS_METHODS
    method create_from( Object object ).WeakReference : native

  METHODS
    method object( Object new_object )  : native
    method object.Object : native

    method to_String.String
      local var obj = object
      if (obj?) return obj.to_String
      return "null"
endClass

class Weak<<$DataType>>
  PROPERTIES
    weak_reference : WeakReference

  METHODS
    method init( Object _object )
      weak_reference = WeakReference( _object )

    method object.$DataType
      return (weak_reference.object coerceAs $DataType)

    method object( Object new_object )
      weak_reference.object = new_object

    method to_String.String
      local var obj = weak_reference.object
      if (obj?) return obj.to_String
      return "null"
endClass

requisite abstract class Object
  # The root class of all objects.  All classes are implicitly
  # or explicitly extended directly or indirectly from class
  # Object.
  #
  # If you don't define a base class then a new class definition implicitly 
  # extends class Object.

  CLASS_METHODS
    method create_duplicate( Object existing ).Object:
      # This factory method initiates object duplication.  The
      # compiler transforms the duplicate(obj) command into 
      # Object.create_duplicate(obj).
      #
      # Returns:
      # * "null" if ''existing'' is null.
      # * existing.create_duplicate otherwise
      if (existing is null) return null
      return existing.create_duplicate

  METHODS
    method init
      # Default initializer.

    native method hash_code.Int32
      # Returns the hash code of this object, which some classes
      # (like HashTable) rely on.  This default implementation
      # returns the lower 32 bits of the object's memory address.
      #
      # Hash codes are used to quickly test and see if two
      # complex objects are NOT equal.  The value returned has no
      # intrinsic meaning, but should conform to the following
      # rules:
      #
      # # Two objects that are equivalent should produce the same hash code.
      # # If an object's state doesn't change, its hash code shouldn't change either.  Internally, this precludes the hash code being based on an object's memory address since in Slag an object's address can change over time.
      #
      # This has the following implications:
      #
      # If you override hash_code you should also override op==() 
      # and possibly op<>() and ensure the following contract.
      #
      # Invariant:
      #
      #   if (obj1.hash_code != obj2.hash_code)
      #     obj1.op==(obj2) == false
      #     obj1.op<>(obj2) != eq
      #   endIf
      #
      #   if (obj1.op==(obj2))
      #     obj1.hash_code == obj2.hash_code
      #   endIf

    method create_duplicate.Object:
      # Override to create a duplicate of this object such that
      # obj1.op==(obj1.create_duplicate) returns true.
      #
      # The command duplicate(obj) is transformed by the compiler
      # into Object.create_duplicate(obj), which then calls this
      # method.
      #
      # For optimal performance (by removing an internal typecast
      # in most situations), have your overridden create_duplicate
      # have the same return type as the class it's defined in.
      # For instance, Strings implementation is 
      # 'create_duplicate.String'.
      #
      # This default implementation throws an UnsupportedMethodError.
      throw UnsupportedMethodError( "create_duplicate() is not defined for class $." (type_name) )

    method to_String.String: 
      # Returns a String representation of this object.  Most classes
      # should override this method to summarize an object's
      # state for convenience in testing and debugging.
      local String st = "($)" (type_name)
      return st

    method op==( Object other ).Logical:    
      # Returns true if this object is equivalant to another.
      #
      # The compiler converts 'obj1 == obj2' into 'obj1.op==(obj2)'
      # and 'obj1 != obj2' into 'not obj1.op==(obj2)'.
      #
      # Implementations of op==() must maintain the following
      # general contract between op==(), op<>(), and 
      # hash_code().
      #
      # Contract:
      #
      #  if (obj1.op==(obj2))
      #    obj1.op<>(obj2) == eq
      #    obj1.hash_code == obj2.hash_code
      #  else
      #    obj1.op<>(obj2) != eq
      #  endIf
      # 
      # Note that two "equal" objects '''must''' have the same hash code,
      # but "unequal" objects may or may not have the same hash code.
      # 
      # This default implementation returns true if the this object and
      # the 'other' reference are the same object ('this is other').
      return (this is other)

    method op<>( Object other ).Int32
      # This method is used for ordering (quantitative) comparisons
      # between this object and another.
      #
      # Returns 'eq' if they're equivalent, 'lt' if this object
      # is "less than" the other, or 'gt' if this object is
      # "greater than" another.
      #
      # The compiler converts:
      #   'obj1 < obj2' -> 'obj1.op<>(obj2) == lt'
      #   'obj1 > obj2' -> 'obj1.op<>(obj2) == gt'
      #   'obj1 <= obj2' -> 'obj1.op<>(obj2) != gt'
      #   'obj1 >= obj2' -> 'obj1.op<>(obj2) != lt'
      #
      # Implementations of op<>() must maintain the following
      # general contract between op==(), op<>(), and 
      # hash_code().
      #
      # Contract:
      #
      #   if (obj1.op<>(obj2) == eq)
      #     obj1.op==(obj2) == true
      #     obj1.hash_code == obj2.hash_code
      #   else
      #     obj1.op==(obj2) == false
      #   endIf
      #
      # Note that two "equal" objects '''must''' have the same hash code,
      # but "unequal" objects may or may not have the same hash code.
      #
      # This default implementation throws an UnsupportedMethodError.
      throw UnsupportedMethodError()

    method type_name.String:
      # Returns the true class name of this object.  The compiler
      # automatically overrides this method in every extended class
      # to return the correct string.
      #
      # Example:
      #
      #   local Object obj = "Hello World"
      #   println( obj.type_name ) # prints: String
      return "Object"

    method runtime_type.RuntimeType
      # Returns the RuntimeType ("class") info for this object if it
      # was declared as a 'runtime' class ("runtime class Actor...")
      # or "null" otherwise.
      #
      # You can also get the RuntimeType by calling Runtime["TypeName"].
      # You can create an runtime type object with Runtime.create("TypeName").
      return Runtime[type_name]
endClass

overlaying aspect Automanaged<<$DataType>>
  # Internal use.  Used with deferred singletons.
  PROPERTIES
    singleton_instance : $DataType

  METHODS
    method get.$DataType: 
      if (singleton_instance is null)
        singleton_instance = $DataType()
      endIf
      return singleton_instance

    method set( singleton_instance ):
endAspect


requisite underlying aspect RequiresCleanup
  # Incorporating this aspect marks objects of the incorporating 
  # class as needing a 'clean_up' call before unused objects are
  # garbage-collected.
  #
  # Don't incorporate this unless you have truly important stuff 
  # to do - each object requiring clean_up slows down garbage 
  # collection with the extra 'clean_up' call.
  #
  # Technical details
  # - Objects requiring cleanup are always allocated on the general
  # heap, never on the fast heap.
  #
  # - Objects requiring cleanup have an associated 'cleanup' flag 
  # set in the memory manager.  When such an object is 
  # unreferenced, 'clean_up' is called on it, the flag is cleared,
  # and the object is left on the general heap.  On the *next*
  # data collection, if still unreferenced, the object will be
  # freed.  This mechanism compensates for the fact that an
  # object could establish another reference to itself in its
  # clean_up method.
  METHODS
    requisite method clean_up: abstract
      # Called on an unreferenced object when its memory is about
      # to be reclaimed.
endAspect


underlying aspect EnumCategory<<$EnumType>>
  PROPERTIES
    ordinal : Int32
      # The positional index value of this enumeration category,
      # corresponding to the order that the categories were 
      # declared in (starting at zero).
      #
      # enum Suit
      #   CATEGORIES
      #     spades, hearts, clubs, diamonds
      # endEnum
      #
      # ...
      # println( Suit.spades.ordinal )  # prints: 0
      # println( Suit.diamonds.ordinal) # prints: 3

    name    : String
      # The name of this category as a string.
      #
      # Suit.spades.name == "spades"

  METHODS
    method init:
      # Default initializer.

    method to_String.String:
      # Returns 'name'
      return name

    method op<>( Object other ).Int32
      return op<>( other.($EnumType) )

    method op<>( $EnumType other ).Int32
      # Returns the relative ordering (lt, eq, gt) of this enum's
      # ordinal versus the ordinal of the given enum.
      local var a = this.ordinal
      local var b = other.ordinal
      if (a < b) return lt
      if (a == b) return eq
      return gt

    method hash_code.Int32:
      # Returns the ordinal value of this enumeration category as its hash code.
      return ordinal
endAspect

aspect GenericEnum;

singleton class Enum<<$EnumType>> : GenericEnum
  # Singleton manager for any 'enum'.  See also "BitFlags"
  #
  # NOTES
  #
  # The compiler converts:
  #   enum Fruit
  #     CATEGORIES
  #       apple, orange
  #     ...
  #   endEnum
  #
  # into:
  #
  #   singleton class Enum<<Fruit>>
  #     PROPERTIES
  #       apple  = prep(Fruit(), "apple")  : Fruit
  #       orange = prep(Fruit(), "orange") : Fruit
  #       ...
  #   endClass
  #
  #   class Fruit : EnumCategory<<Fruit>>
  #     SINGLETONS
  #       Enum<<Fruit>>
  #
  #     METHODS
  #       method init: noAction
  #       ...
  #   endClass

  PROPERTIES
    by_ordinal : $EnumType[]
    by_name    : HashTable<<String,$EnumType>>

  METHODS
    method prep( $EnumType category, String name ).$EnumType:
      # Internal use.
      if (by_ordinal is null)
        by_ordinal = $EnumType{}
        by_name = HashTable<<String,$EnumType>>()
      endIf
      category.ordinal = by_ordinal.count
      category.name = name
      by_name[name] = category
      by_ordinal.add( category )
      return category

    method includes( String name ).Logical:
      # Returns "true" if the given name is a category of this 
      # enumeration.
      #
      # Example:
      #   Fruit.includes("carrot") -> false
      return by_name.contains( name )

endClass


overlaying aspect BitFlags<<$EnumType>>
  # Incorporate this aspect into enumerated types associated with
  # Int32 values that define bit flags. 
  #
  # For example:
  #
  #   enum Direction : BitFlags<<Direction>>
  #     CATEGORIES
  #       north(1), east(2), south(4), west(8)
  #   endEnum
  #
  #   ...
  #   local Direction d = Direction.north | Direction.east
  #   println( d == Direction.north )         # prints: false
  #   println( d.includes(Direction.north) )  # prints: true
  #   println( d )        # prints: north,east
  #   println( d.flags )  # prints: 3
  #   d &= !Direction.north
  #   println( d )  # prints: east
  #   println( d == Direction.east )  # prints: true
  #   println( d.flags )  # prints: 2
  CLASS_PROPERTIES
    default_next_flag : Int32

  PROPERTIES
    flags : Int32

  METHODS
    method init:
      if (default_next_flag == 0) default_next_flag = 1
      flags = default_next_flag
      default_next_flag = default_next_flag.left_shifted(1)

    method init( flags ):
      if (default_next_flag == 0) default_next_flag = flags
      default_next_flag = default_next_flag.left_shifted(1)

    method init( $EnumType existing ):
      init( existing.flags )

    method op|( $EnumType other ).$EnumType:
      # Returns a new category that includes all the bitflags
      # from this category and the 'other' category.
      return $EnumType( flags | other.flags )

    method op|( Int32 other_flags ).$EnumType:
      # Returns a new category that includes all the bitflags
      # from this category and 'other_flags'.
      return $EnumType( flags | other_flags )

    method op&( $EnumType other ).$EnumType:
      # Returns a new category that contains the intersection
      # of bitflags from this category and the 'other' category.
      return $EnumType( flags & other.flags )

    method op&( Int32 other_flags ).$EnumType:
      # Returns a new category that contains the intersection
      # of bitflags from this category and 'other_flags'.
      return $EnumType( flags & other_flags )

    method op!.$EnumType:
      # Returns a new category that contains the inverse
      # of this category's bitflags.
      return $EnumType( !flags )

    method includes( $EnumType other ).Logical:
      # Returns "true" if this category contains any of the
      # bitflags from the 'other' category.
      return (flags & other.flags) != 0

    method includes( Int32 other_flags ).Logical:
      # Returns "true" if this category contains any of the
      # bitflags from 'other_flags'.
      return (flags & other_flags) != 0

    method op==( Object other ).Logical:
      if (other instanceOf $EnumType) return flags == other.($EnumType).flags
      return false

    method op==( $EnumType other ).Logical:
      return (flags == other.flags)

    method op==( Int32 other_flags ).Logical:
      return (flags == other_flags)

    method to_String.String:
      # Returns a string containing the names of all comma-separated
      # categories included in this category's bitflags.
      local String result;
      forEach (category in $EnumType.by_ordinal)
        if (category.includes(flags))
          if (result is null) result = category.name
          else result = "$,$" (result,category.name)
        endIf
      endForEach
      return result
endAspect

#=====================================================================
# Degrees, Radians, Math
#=====================================================================

compound Degrees( Real64 value )
  # Compound that wraps a Real64 value that specifies an angle in degrees.
  #
  # Degrees compounds may be used in trig operations such as
  # sin() and cos().
  #
  #
  # ==== See Also ====
  # * [[SlagDoc:DegreesManager|DegreesManager]]
  # * [[SlagDoc:Radians|Radians]]

compound Radians( Real64 value )
  # Compound that wraps a Real64 value that specifies an angle in radians.
  #
  # Radians compounds may be used in trig operations such as
  # sin() and cos().
  #
  #
  # ==== See Also ====
  # * [[SlagDoc:RadiansManager|RadiansManager]]
  # * [[SlagDoc:Degrees|Degrees]]

singleton class DegreesManager
  # Implements methods for Degrees compound values, allowing them
  # to be used with standard arithmetic operators.

  METHODS
    method create_from( Radians rad ).Degrees:
      # Creates a Degrees value of the same angle as 'rad'.
      return to_Degrees(rad)

    method to_String( Degrees deg ).String:
      # Returns the value in degrees as a string.
      return to_String(deg.value)

    method to_Radians( Degrees deg ).Radians:
      # Converts the given value from degrees into radians.
      return Radians((deg.value/180.0)*pi)

    method op+( Degrees deg1, Degrees deg2 ).Degrees:
      # Returns the sum of two angles.  Called automatically
      # when there's an expression of the form "a1 + a2".
      return Degrees( deg1.value + deg2.value )

    method op-( Degrees deg1, Degrees deg2 ).Degrees:
      # Returns the difference of two angles.  Called automatically
      # when there's an expression of the form "a1 - a2".
      #
      # Subtraction in particular normalizes the return value to be the 
      # shortest number of degrees to get from ''deg2'' to ''deg1''.  
      # So Degrees(0) minus Degrees(270) -> Degrees(90), since turning 90
      # degrees will get you to 0 degrees faster than turning
      # -270 degrees.
      local var diff = deg1.value - deg2.value
      diff %= 360
      if (diff > 180) diff = -(360 - diff)
      return Degrees(diff)

    method op+( Degrees deg, Radians rad ).Degrees:
      # Returns the sum of two angles.  Called automatically
      # when there's an expression of the form "a1 + a2".
      return deg + to_Degrees(rad)

    method op-( Degrees deg, Radians rad ).Degrees:
      # Returns the difference of two angles.  Called automatically
      # when there's an expression of the form "a1 - a2".
      return deg - to_Degrees(rad)

    method op-( Degrees deg1 ).Degrees:
      # Returns the negative of the given angle.  Called automatically
      # when there's an expression of the form "-a".
      return Degrees( -deg1.value )

    method op*( Degrees deg, Real64 factor ).Degrees:
      # Returns ''deg'' scaled by ''factor''.
      return Degrees( deg.value * factor )

    method op*( Real64 factor, Degrees deg ).Degrees:
      # Returns ''deg'' scaled by ''factor''.
      return Degrees( deg.value * factor )

    method op/( Degrees deg, Real64 factor ).Degrees:
      # Returns ''deg'' scaled by ''factor''.
      return Degrees( deg.value / factor )

    method op/( Real64 factor, Degrees deg ).Degrees:
      # Returns ''deg'' scaled by ''factor''.
      return Degrees( factor / deg.value )

    method op%( Degrees deg, Real64 factor ).Degrees:
      # Returns ''deg'' mod ''factor''.
      return Degrees( deg.value % factor )

    method op%( Real64 factor, Degrees deg ).Degrees:
      # Returns ''deg'' mod ''factor''.
      return Degrees( factor % deg.value )

endClass

singleton class RadiansManager
  # Implements methods for Radians compound values, allowing them
  # to be used with standard arithmetic operators.

  METHODS
    method create_from( Degrees deg ).Radians:
      # Creates a Radians value of the same angle as ''deg''.
      return to_Radians(deg)

    method to_String( Radians rad ).String:
      # Returns the value in radians as a string.
      return to_String(rad.value)

    method to_Degrees( Radians rad ).Degrees:
      # Converts the given value from radians into degrees.
      return Degrees( (rad.value/pi)*180.0 )

    method op+( Radians rad1, Radians rad2 ).Radians:
      # Returns the sum of two angles.  Called automatically
      # when there's an expression of the form "a1 + a2".
      return Radians( rad1.value + rad2.value )

    method op-( Radians rad1, Radians rad2 ).Radians:
      # Returns the difference of two angles.  Called 
      # automatically when there's an expression of the form "a1 - a2".
      #
      # Subtraction in particular normalizes the return value to be the 
      # shortest number of radians to get from ''rad2'' to ''rad1''.  
      # So Radians(0) minus Radians(3.0/2.0*pi) -> Radians(pi/2), since 
      # turning pi/2 will get you to 0 faster than turning -3/2pi.
      local var diff = rad1.value - rad2.value
      diff %= 2*pi
      if (diff > pi) diff = -(pi*2 - diff)
      return Radians(diff)

    method op+( Radians rad, Degrees deg ).Radians:
      # Returns the sum of two angles.  Called automatically
      # when there's an expression of the form "a1 + a2".
      return rad + to_Radians(deg)

    method op-( Radians rad, Degrees deg ).Radians:
      # Returns the difference of two angles.  Called automatically
      # when there's an expression of the form "a1 - a2".
      return rad - to_Radians(deg)

    method op-( Radians rad1 ).Radians:
      # Returns the negative of the given angle.  Called automatically
      # when there's an expression of the form "-a".
      return Radians( -rad1.value )

    method op*( Radians rad, Real64 factor ).Radians:
      # Returns ''rad'' scaled by ''factor''.
      return Radians( rad.value * factor )

    method op*( Real64 factor, Radians rad ).Radians:
      # Returns ''rad'' scaled by ''factor''.
      return Radians( rad.value * factor )

    method op/( Radians rad, Real64 factor ).Radians:
      # Returns ''rad'' scaled by ''factor''.
      return Radians( rad.value / factor )

    method op/( Real64 factor, Radians rad ).Radians:
      # Returns ''rad'' scaled by ''factor''.
      return Radians( factor / rad.value )

    method op%( Radians rad, Real64 factor ).Radians:
      # Returns ''rad'' mod ''factor''.
      return Radians( rad.value % factor )

    method op%( Real64 factor, Radians rad ).Radians:
      # Returns ''rad'' mod ''factor''.
      return Radians( factor % rad.value )

endClass

augment RandomNumberGenerator
  METHODS
    method random_Degrees.Degrees:
      # Returns a random angle in the range (0,360) exclusive.
      return Degrees( random_Real64 * 360 )

    method random_Radians.Radians:
      # Returns a random angle in the range (0,2*pi) exclusive.
      return Radians( random_Real64 * 2 * pi )
endAugment

singleton class Math
  # Math functions.
  SINGLETONS
    DegreesManager, RadiansManager, RandomNumberGenerator

  PROPERTIES
    e = 2.718281828459045 : Real64
    next_unique_Int32=1 : Int32
      # Counter for unique_Int32().

  METHODS
    method abs( Int64 n ).Int64:     native
      # Returns the absolute value of 'n'.

    method abs( Int32 n ).Int32:
      # Returns the absolute value of 'n'.
      return Int32(abs( Int64(n) ))

    method abs( Real64 n ).Real64:   native
      # Returns the absolute value of 'n'.

    method floor( Real64 n ).Real64: native
      # Returns the value of 'n' rounded down.
      #
      #   println( floor(3.9) )  # prints:  3
      #   println( floor(-3.9) ) # prints: -4

    method round( Real64 n ).Real64:
      # Returns the value of 'n' rounded off.
      #
      #   println( round(3.4) )  # prints:  3
      #   println( round(3.5) )  # prints:  4
      #   println( round(-3.4) ) # prints: -4
      #   println( round(-3.5) ) # prints: -3
      return floor( n + 0.5 )

    method ceiling( Real64 n ).Real64:
      # Rounds ''n'' up to the nearest value.
      #
      # Examples:
      #   ceiling( 3.0 ) is 3
      #   ceiling( 3.1 ) is 4
      local var floor_of_n = floor(n)
      if (n - floor_of_n != 0.0) return floor_of_n + 1
      return floor_of_n

    method sign( Int64 n ).Int64:
      # Returns the sign of 'n' as an Int64 value:
      #    1 when n  > 0
      #   -1 when n  < 0
      #    0 when n == 0
      if (n > 0) return Int64(1)
      if (n < 0) return Int64(-1)
      return Int64(0)

    method sign( Int32 n ).Int32:
      # Returns the sign of 'n' as an Int32 value:
      #    1 when n  > 0
      #   -1 when n  < 0
      #    0 when n == 0
      if (n > 0) return 1
      if (n < 0) return -1
      return 0

    method sign( Real64 n ).Real64:
      # Returns the sign of 'n' as an Real64 value:
      #    1 when n  > 0
      #   -1 when n  < 0
      #    0 when n == 0
      if (n > 0) return 1.0
      if (n < 0) return -1.0
      return 0.0

    method sqrt( Real64 n ).Real64:  native
      # Returns the square root of 'n'.

    method sqrt( Int64  n ).Int64:
      # Returns the square root of 'n'.
      return Int64(sqrt(Real64(n)))

    method sqrt( Int32  n ).Int32:
      # Returns the square root of 'n'.
      return Int32(sqrt(Real64(n)))

    method sin( Radians rad ).Real64: native
      # Returns the sine value of angle 'rad'.
      #
      # Given a vector of angle 'rad', the sine value tells us what 
      # proportion of that line lies along the y axis.

    method sin( Degrees deg ).Real64:
      # Returns the sine value of angle 'deg'.
      #
      # Given a vector of angle 'deg', the sine value tells us what 
      # proportion of that line lies along the y axis.
      return sin( to_Radians(deg) )

    method cos( Radians rad ).Real64: native
      # Returns the cosine value of angle 'rad'.
      #
      # Given a vector of angle 'rad', the cosine value tells us what
      # proportion of that line lies along the x axis.

    method cos( Degrees deg ).Real64:
      # Returns the cosine value of angle 'deg'.
      #
      # Given a vector of angle 'deg', the cosine value tells us what
      # proportion of that line lies along the x axis.
      return cos( to_Radians(deg) )

    method tan( Radians rad ).Real64: native
      # Returns the tangent value of angle 'rad'.
      #
      # Given a vector of angle 'rad', the tangent value gies us the
      # slope (y/x) of that vector.

    method tan( Degrees deg ).Real64:
      # Returns the tangent value of angle 'deg'.
      #
      # Given a vector of angle 'deg', the tangent value gies us the
      # slope (y/x) of that vector.
      return tan( to_Radians(deg) )

    method asin( Real64 yp ).Radians: native
      # Returns the arcsine (or "sin^-1") of 'yp'.  This is the
      # angle that a vector would have to be at to have a 
      # proportional length 'yp' along the y axis.

    method acos( Real64 xp ).Radians: native
      # Returns the arccosine (or "cos^-1") of 'xp'.  This is the
      # angle that a vector would have to be at to have a 
      # proportional length 'xp' along the x axis.

    method atan( Real64 slope ).Radians: native
      # Returns the arctangent (or "tan^-1") of 'slope'.  This is
      # the angle of the vector that has the given y/x 'slope'.
      #
      # Note: slopes do not have a direction associated with them
      # like vectors do; therefore "atan(1.0/1.0)" is the same as 
      # "atan(-1.0/-1.0)".  Use atan2(Real64,Real64) to take 
      # direction into account.

    method atan2( Real64 y, Real64 x ).Radians: native
      # Returns the arctangent (or "tan^-1") of slope 'y'/'x'.  This 
      # is the angle of the vector that has that slope.
      #
      # Unlike atan(Real64), this method takes the direction into
      # account - atan2(1.0,1.0) will give a different answer than
      # atan2(-1.0,-1.0).

    method fractional_part( Real64 n ).Real64: 
      # Returns the fractional part of the given value.
      #
      # Example:
      #   println( fractional_part(3.9) )  # prints: 0.9
      return n - floor(n)

    method clamped( Real64 num, Real64 low, Real64 high ).Real64:
      # Returns:
      #   'low' if num < low
      #   'high' if num > high
      #   'num' otherwise
      #
      # Example:
      #   num = num.clamped(1,10)
      if (num < low) return low
      if (num > high) return high
      return num

    method clamped( Int64 num, Int64 low, Int64 high ).Int64:
      # Returns:
      #   'low' if num < low
      #   'high' if num > high
      #   'num' otherwise
      #
      # Example:
      #   num = num.clamped(1,10)
      if (num < low) return low
      if (num > high) return high
      return num

    method clamped( Int32 num, Int32 low, Int32 high ).Int32:
      # Returns:
      #   'low' if num < low
      #   'high' if num > high
      #   'num' otherwise
      #
      # Example:
      #   num = num.clamped(1,10)
      if (num < low) return low
      if (num > high) return high
      return num

    method wrapped( Real64 num, Real64 low, Real64 high ).Real64:
      # Returns 'num' constrained to the number cycle low..high;
      # similar to modulo.
      #
      # Example:
      #   num = 2.2
      #   println( num.wrapped(0,1) )    # prints: 0.2000
      #   println( num.wrapped(1.5,2) )  # prints: 1.7000
      #   println( num.wrapped(2.5,3) )  # prints: 2.7
      return ((num - low) % (high - low)) + low

    method wrapped( Int64 num, Int64 low, Int64 high ).Int64:
      # Returns 'num' constrained to the number cycle low..high;
      # similar to modulo.
      #
      # Example:
      #   println( wrapped(8,1,6) )   # prints: 2
      #   println( wrapped(-7,1,6) )  # prints: 5
      return ((num - low) % (high - low + 1)) + low

    method wrapped( Int32 num, Int32 low, Int32 high ).Int32:
      # Returns 'num' constrained to the number cycle low..high;
      # similar to modulo.
      #
      # Example:
      #   println( wrapped(8,1,6) )   # prints: 2
      #   println( wrapped(-7,1,6) )  # prints: 5
      return ((num - low) % (high - low + 1)) + low

    method min( Real64 a, Real64 b ).Real64: 
      # Returns the lowest of the two values 'a' and 'b'.
      if (a < b) return a
      else return b

    method min( Int64 a, Int64 b ).Int64:    
      # Returns the lowest of the two values 'a' and 'b'.
      if (a < b) return a
      else return b

    method min( Int32 a, Int32 b ).Int32:    
      # Returns the lowest of the two values 'a' and 'b'.
      if (a < b) return a
      else return b

    method max( Real64 a, Real64 b ).Real64: 
      # Returns the highest of the two values 'a' and 'b'.
      if (a > b) return a
      else return b

    method max( Int64 a, Int64 b ).Int64:    
      # Returns the highest of the two values 'a' and 'b'.
      if (a > b) return a
      else return b

    method max( Int32 a, Int32 b ).Int32:    
      # Returns the highest of the two values 'a' and 'b'.
      if (a > b) return a
      else return b

    method is_odd( Int64 n ).Logical:
      # Returns "true" if 'n' is an odd number.
      return ((n & 1) == 1)

    method is_odd( Int32 n ).Logical:
      # Returns "true" if 'n' is an odd number.
      return ((n & 1) == 1)

    method is_even( Int64 n ).Logical:
      # Returns "true" if 'n' is an even number.
      return ((n & 1) == 0)

    method is_even( Int32 n ).Logical:
      # Returns "true" if 'n' is an even number.
      return ((n & 1) == 0)

    method is_NaN( Real64 n ).Logical:
      # "Not a number" (NaN) values can't be compared normally; for example
      # (NaN == NaN) is false.  The Slag compiler detects comparisons against
      # literal "NaN" and calls this method.  This method can also be called
      # when comparing against a variable that may or may not be a NaN value.
      local var a = (((n as Int64) & 0x7ff0000000000000) == 0x7ff0000000000000)
      local var b = (((n as Int64) & 0xfffffffffffff) != 0)
      return (((n as Int64) & 0x7ff0000000000000) == 0x7ff0000000000000) and ...
        (((n as Int64) & 0xfffffffffffff) != 0)

    method is_NaN( Real32 n ).Logical:
      # "Not a number" (NaN) values can't be compared normally; for example
      # (NaN == NaN) is false.  The Slag compiler detects comparisons against
      # literal "NaN" and calls this method.  This method can also be called
      # when comparing against a variable that may or may not be a NaN value.
      return is_NaN( Real64(n) )

    method unique_Int32.Int32:
      # Returns a positive number that is unique within the current run of the program
      # (but not across multiple runs).
      ++next_unique_Int32
      return (next_unique_Int32 - 1)
endClass

singleton class BitwiseOperations
  # Routines for the bitwise manipulation of numbers.  These methods
  # are globally accessible.
  #
  # Example:
  #   local var x = 3
  #   println( x.left_shifted(1) )  # prints: 6

  METHODS
    # Except for left & right rotated, bit manipulation methods are intercepted 
    # by the compiler and become opcodes.

    method left_rotated(  Int64 n, Int32 bits ).Int64:
      # Returns 'n' with its bits left-rotated by 'bits' digits.
      if (bits == 0) return n

      return (n.left_shifted(bits)) ...
        | (n.right_shifted(64 - bits) & (Int64(1).left_shifted(bits) - 1))

    method right_rotated(  Int64 n, Int32 bits ).Int64:
      # Returns 'n' with its bits right-rotated by 'bits' digits.
      if (bits == 0) return n

      local Int32 lower_bit_count = (64 - bits)
      return (n.right_xshifted(bits) & (SlagInt64(1).left_shifted(lower_bit_count)-1))...
        | n.left_shifted(lower_bit_count)

    method left_shifted(  Int64 n, Int32 num_bits ).Int64: native
      # Returns 'n' with its bits left-shifted by 'num_bits' digits.
      # Zero bits are shifted in on the right side.

    method right_shifted(  Int64 n, Int32 num_bits ).Int64: native
      # Returns 'n' with its bits right-shifted by 'num_bits' digits.
      # Zero bits are shifted in on the right side.

    method right_xshifted( Int64 n, Int32 num_bits ).Int64: native
      # Returns 'n' with its bits right-shifted by 'num_bits' digits.
      # The most significant bit is duplicated with each shift to
      # preserve the sign of the number.

    method left_rotated(  Int32 n, Int32 bits ).Int32:
      # Returns 'n' with its bits left-rotated by 'bits' digits.
      n &= 0xFFFFFFFF
      if (bits == 0) return n

      n = (n.left_shifted(bits)) | (n.right_shifted(32 - bits) & (1.left_shifted(bits) - 1))
      return n & 0xFFFFFFFF

    method right_rotated(  Int32 n, Int32 bits ).Int32:
      # Returns 'n' with its bits right-rotated by 'bits' digits.
      n &= 0xFFFFFFFF
      if (bits == 0) return n

      local Int32 lower_bit_count = (32 - bits)
      n = (n.right_xshifted(bits) & (1.left_shifted(lower_bit_count)-1))...
        | n.left_shifted(lower_bit_count)
      return n & 0xFFFFFFFF

    method left_shifted(  Int32 n, Int32 num_bits ).Int32: native
      # Returns 'n' with its bits left-shifted by 'num_bits' digits.
      # Zero bits are shifted in on the right side.

    method right_shifted(  Int32 n, Int32 num_bits ).Int32: native
      # Returns 'n' with its bits right-shifted by 'num_bits' digits.
      # Zero bits are shifted in on the right side.

    method right_xshifted( Int32 n, Int32 num_bits ).Int32: native
      # Returns 'n' with its bits right-shifted by 'num_bits' digits.
      # The most significant bit is duplicated with each shift to
      # preserve the sign of the number.

    method is_power_of_two( Int64 n ).Logical:
      # Returns "true" if 'n' is a power of 2.
      return (n & (n-1)) == 0

    method is_power_of_two( Int32 n ).Logical:
      # Returns "true" if 'n' is a power of 2.
      return (n & (n-1)) == 0

    method min_bits( Int64 n ).Int32:
      # Returns the minimum number of bits required to represent the
      # given value.  For example, min_bits(4) would return 3, 
      # since 3 bits can represent the values 0..7.
      #
      # Invariant:
      #   result >= 1 and result <= 64
      #   (2^result-1) >= n
      #   if (n < 0) result == 64
      if (n < 0)                   return 64
      if (n >= 0x4000000000000000) return 63
      local Int32 bits = 1
      while ( 1.left_shifted(bits) <= n ) bits++
      return bits

    method min_bits( Int32 n ).Int32:
      # Returns the minimum number of bits required to represent the
      # given value.  For example, min_bits(4) would return 3, 
      # since 3 bits can represent the values 0..7.
      #
      # Invariant:
      #   result >= 1 and result <= 32
      #   (2^result-1) >= n
      #   if (n < 0) result == 32
      if (n < 0)           return 32
      if (n >= 0x40000000) return 31
      local Int32 bits = 1
      while ( 1.left_shifted(bits) <= n ) bits++
      return bits

    method rounded_up_to_power_of_two( Int32 n ).Int32:
      # Returns 'n' rounded up to the next power of 2.  If it is
      # already a power of two it is returned unmodified.
      #
      # Requires:
      #   n >= 0
      #
      # Invariant:
      #   2^(result-1) < n and 2^(result) >= n
      if (n.is_power_of_two) return n
      return 1.left_shifted( n.min_bits )

endClass

class Date
  PROPERTIES
    year, month, day, hour, minute, second, millisecond : Int32

  METHODS
    method init:
      # Initializes with current date.
      init(time_ms)

    method init( Int64 ms ): native
      # Initializes this date with the given millisecond timestamp.

    method init( year, month, day, hour=0, minute=0, second=0, millisecond=0 ):

    method timestamp.Int64: native
      # Converts this Date into a millisecond timestamp.  Does not include
      # the original millisecond value in order to be compatible with
      # File timestamps that have a granularity in seconds.

    method to_String.String:
      return "$.$(02).$(02) $(02):$(02):$(02)" (year,month,day,hour,minute,second)
endClass

requisite singleton class Global
  # Defines the global methods and variables that form the core
  # of Slag's API.
  SINGLETONS
    Math, BitwiseOperations

  PROPERTIES
    command_line_args() : String[]
      # Java-style command line arguments.  If a slag program 
      # "echo.slag" is compiled to an ETC file and run like this:
      #
      #   slag echo hello world
      #
      # or compiled to an exe and run like this:
      #
      #   echo hello world
      #
      # Then command_line_args[0] will contain "hello" and
      # command_line_args[1] will contain "world".

    stdin        : Reader<<Char>>
      # A Reader<<Char>> that reads characters from the standard 
      # input.  This is typically configured to be the keyboard.

    stdout       : TextWriter
      # A Writer<<Char>> that writes characters to the standard
      # output.  This is typically configured to be the console
      # window.

  METHODS
    method init:
      # Internal use.
      set_up_stdio

    method set_up_stdio:
      # Sets up stdin and stdout.
      if (stdin is null) 
        stdin = StdInReader()
      endIf
      if (stdout is null) stdout = StdOutWriter()

    method print( Char n ):
      # Prints the given Char to stdout.  The symbol corresponding
      # to the Unicode value of 'n' will be displayed.
      stdout.print( n )

    method print( Object obj ): 
      # Prints the to_String() value of the given Object to stdout.
      # If the 'obj' reference is null, the word "null" is printed 
      # out instead.
      if (obj is null) stdout.print( "null" )
      else stdout.print( obj.to_String )

    method print( String st ):
      # Prints the given string to stdout.  We need specifically need this method 
      # in addition to println(Object) to handle printing compounds since the 
      # compiler will convert a compound to a String automatically if a 
      # single-parameter method requires a string.
      if (st is null) stdout.print( "null" )
      else stdout.print( st )

    method print( Int64   n ):
      # Prints the given Int64 to stdout as a human-readable series of
      # digits.
      print( to_String(n) )

    method print( Byte n ):
      # Prints the given Byte to stdout as a human-readable series of
      # digits.
      print( to_String(n) )

    method print( Real64 n ):
      # Prints the given Real64 to stdout as a human-readable series 
      # of digits.
      print( to_String(n) )

    method print( Logical n ):
      # Prints the given Logical to stdout as the word "true" or "false".
      print( to_String(n) )

    method println( Object obj ):
      # Prints the given object and advances the cursor to the next
      # line.
      print( obj ); 
      println()

    method println( String st ):
      # Prints the given string to stdout and advances the cursor to
      # the next line.  We need specifically need this method 
      # in addition to println(Object) to handle printing compounds since the 
      # compiler will convert a compound to a String automatically if a 
      # single-parameter method requires a string.
      print( st ); println()

    method println( Int64   n ):
      # Prints the given Int64 value and advances the cursor to the
      # next line.
      print( n ); println()

    method println( Byte   n ):
      # Prints the given Byte value and advances the cursor to the
      # next line.
      print( n ); println()

    method println( Char    n ):
      # Prints the given Char value and advances the cursor to the
      # next line.
      print( n ); println()

    method println( Real64  n ):
      # Prints the given Real64 value and advances the cursor to the
      # next line.
      print( n ); println()

    method println( Logical n ):
      # Prints the given Logical value and advances the cursor to the
      # next line.
      print( n ); println()

    method println:
      # Moves the cursor to the next line.
      print( "\n" )

    method read_line.String:
      # Reads a line of text in from the user - up to the [ENTER]
      # key being pressed - and returns the line of text as a
      # String.  The end-of-line characters are not part of the
      # string and are discarded.
      return stdin.read_line

    method read_Int32.Int32:
      # Reads a line of text in from the user - up to the [ENTER]
      # key being pressed - and attempts to parse an Int32 value
      # from the text.  If the input is not a well-formed integer
      # value then an InvalidOperandError is thrown.
      return NumberConversions.parse_Int32( read_line )

    method read_Int64.Int64:
      # Reads a line of text in from the user - up to the [ENTER]
      # key being pressed - and attempts to parse an Int64 value
      # from the text.  If the input is not a well-formed integer
      # value then an InvalidOperandError is thrown.
      return NumberConversions.parse_Int64( read_line() )

    method input_Int32( String prompt="Enter number: " ).Int32:
      # Displays the given prompt and calls read_Int32 to read
      # and return a number.
      print( prompt )
      return read_Int32

    method input_Int64( String prompt="Enter number: " ).Int64:
      # Displays the given prompt and calls read_Int64 to read
      # and return a number.
      print( prompt )
      return read_Int64

    method input_String( String prompt="Enter text: " ).String:
      # Displays the given prompt and calls read_line to read
      # and return a number.
      print( prompt )
      return read_line

    method debug_assert( Logical value ):
      # If you [define DEBUG] at the top of your program, then
      # typing ASSERT(logical-expression) will call this method.
      if (not value)
        local Error err( "Debug assertion failed." )
        throw err
      endIf

    method time_ms.Int64: native
      # Returns the current time in milliseconds since January 1, 
      # 1970.
      #
      # Example:
      #   local var start_ms = time_ms
      #   ...code...
      #   local var elapsed_ms = time_ms - start_ms
      #   println( "Elapsed time: $ seconds" (elapsed_ms / 1000.0) )

    method sleep( Int32 ms ): native
      # Puts this program to sleep for the given number of milliseconds.
      # For example, to sleep for 2.5 seconds:
      #
      #   sleep( 2500 )

    method to_String( Object obj ).String:
      # Returns the string representation of the given object.  
      # Returns "null" if the 'obj' reference is null, else returns
      # the result of obj.to_String().
      if (obj is null) return "null"
      return obj.to_String

    method to_String( Exception err ).String:
      # Returns the string representation of the given exception.
      # Returns "null" if the reference is null, else returns
      # the result of err.to_String().
      #
      # Note: on some platforms (C#/WP7), exceptions are not extended
      # from Slag class Object and thus some methods require both
      # an 'Object' and an 'Exception' version.
      if (err is null) return "null"
      return err.to_String

    method to_String( String st ).String:
      # Returns the given object.  We need this method specifically to
      # handle printing compounds since the compiler will convert a compound
      # to a String automatically if a single-parameter method requires a string.
      return st

    method to_String( Int64 n ).String:
      # Returns a string representation of 'n'.
      return to_String( n, 10 )

    method to_String( Int32 n ).String:
      # Returns a string representation of 'n'.
      return to_String( n, 10 )

    method to_String( Char ch ).String:
      # Returns a string representation of ''ch''.  This will be a 
      # string containing ''ch'' as its single character.
      return String.create_from(ch)

    method to_String( Byte n ).String:
      # Returns a string representation of 'n'.
      return to_String( n, 10 )

    method to_String( Real64 n ).String:
      # Returns a string representation of 'n'.
      return NumberConversions.Real64_to_String( n, 10 )

    method to_String( Logical n ).String:
      # Returns a string representation of logical 'n' as "true" or "false".
      if (n) return "true"
      else   return "false"

    method to_String( Int64 n, Int32 base ).String:
      # Returns a string representation of 'n' in the specified base.
      # If 'base' is 2 or 16 then exactly 64 or 16 digits will be
      # returned, respectively.
      which (base)
        case 2:  return NumberConversions.Int64_to_String( n,  2, 64 )
        case 4:  return NumberConversions.Int64_to_String( n,  4, 32 )
        case 8:  return NumberConversions.Int64_to_String( n,  8, 22 )
        case 16: return NumberConversions.Int64_to_String( n, 16, 16 )
        others:  return NumberConversions.Int64_to_String( n, base )
      endWhich

    method to_String( Int32 n, Int32 base ).String:
      # Returns a string representation of 'n' in the specified base.
      # If 'base' is 2 or 16 then exactly 32 or 8 digits will be
      # returned, respectively.
      which (base)
        case 2:  return NumberConversions.Int64_to_String( n,  2, 32 )
        case 4:  return NumberConversions.Int64_to_String( n,  4, 16 )
        case 8:  return NumberConversions.Int64_to_String( n,  8, 11 )
        case 16: return NumberConversions.Int64_to_String( n, 16,  8 )
        others:  return NumberConversions.Int64_to_String( n, base )
      endWhich

    method to_String( Char ch, Int32 base ).String:
      # Returns a string representation of 'n' in the specified base.
      # If 'base' is 2 or 16 then exactly 16 or 8 digits will be
      # returned, respectively.  Note that to_String('A') returns
      # "A" while to_String('A',10) returns "65".
      which (base)
        case 2:  return NumberConversions.Int64_to_String( ch,  2, 16 )
        case 4:  return NumberConversions.Int64_to_String( ch,  4,  8 )
        case 8:  return NumberConversions.Int64_to_String( ch,  8,  6 )
        case 16: return NumberConversions.Int64_to_String( ch, 16,  4 )
        others:  return NumberConversions.Int64_to_String( ch, base )
      endWhich

    method to_String( Byte n, Int32 base ).String:
      # Returns a string representation of 'n' in the specified base.
      # If 'base' is 2 or 16 then exactly 8 or 2 digits will be
      # returned, respectively.
      which (base)
        case 2:  return NumberConversions.Int64_to_String( n,  2,  8 )
        case 4:  return NumberConversions.Int64_to_String( n,  4,  4 )
        case 8:  return NumberConversions.Int64_to_String( n,  8,  3 )
        case 16: return NumberConversions.Int64_to_String( n, 16,  2 )
        others:  return NumberConversions.Int64_to_String( n, base )
      endWhich

    method format_string( String st, Int32 whole_digits, Int32 decimal_digits, Char fill_char=' ' ).String:
      # Returns a formatted string representation of 'num'.
      if (st is null) st = "null"
      if (st.count >= whole_digits) return st
      local StringBuilder formatted()
      forEach (1 .. (whole_digits - st.count)) formatted.print( fill_char )
      formatted.print( st )
      return formatted.to_String

    method format_string( Real64 num, Int32 whole_digits, Int32 decimal_digits, Char fill_char=' ' ).String:
      # Returns a formatted string representation of 'num'.
      return format_string( 
        NumberConversions.Real64_to_String(num,10,whole_digits,decimal_digits,fill_char),
        whole_digits, decimal_digits, fill_char
      )
      
    method format_string( Int64 num, Int32 whole_digits, Int32 decimal_digits, Char fill_char=' ' ).String:
      # Returns a formatted string representation of 'num'.
      return format_string( to_String(num), whole_digits, decimal_digits, fill_char )

    method format_string( Int32 num, Int32 whole_digits, Int32 decimal_digits, Char fill_char=' ' ).String:
      # Returns a formatted string representation of 'num'.
      return format_string( to_String(num), whole_digits, decimal_digits, fill_char )

    method format_string( Char num, Int32 whole_digits, Int32 decimal_digits, Char fill_char=' ' ).String:
      # Returns a formatted string representation of 'num'.
      return format_string( to_String(num), whole_digits, decimal_digits, fill_char )

    method format_string( Byte num, Int32 whole_digits, Int32 decimal_digits, Char fill_char=' ' ).String:
      # Returns a formatted string representation of 'num'.
      return format_string( to_String(num), whole_digits, decimal_digits, fill_char )

    method format_string( Logical num, Int32 whole_digits, Int32 decimal_digits, Char fill_char=' ' ).String:
      # Returns a formatted string representation of 'num'.
      return format_string( to_String(num), whole_digits, decimal_digits, fill_char )

    method format_string( Object obj, Int32 whole_digits, Int32 decimal_digits, Char fill_char=' ' ).String:
      # Returns a formatted string representation of 'obj'.
      if (obj is null) return format_string( "null", whole_digits, decimal_digits, fill_char )
      return format_string( obj.to_String, whole_digits, decimal_digits, fill_char )

    method is_letter( Char ch ).Logical:
      # Returns "true" if ''ch'' is a letter of the alphabet (A-Z, a-z).
      return (ch >= 'a' and ch <= 'z') or (ch >= 'A' and ch <= 'Z')

    method is_uppercase( Char ch ).Logical:
      # Returns "true" if ''ch'' is an uppercase letter (A-Z).
      return (ch >= 'A' and ch <= 'Z')

    method is_lowercase( Char ch ).Logical:
      # Returns "true" if ''ch'' is an lowercase letter (a-z).
      return (ch >= 'a' and ch <= 'z')

    method is_hex_digit( Char ch ).Logical:
      # Returns "true" if ''ch'' is an base-16 digit (0-9, a-f, A-F).
      return ch.is_digit(16)

    method is_digit( Char ch, Int32 base=10 ).Logical:
      # Returns true if the given character is a valid digit in the
      # specified number base (2 to 36 where bases greater than
      # 10 accept characters "a..z" or "A..Z" as digits 10..35).
      local var value = to_value(ch)
      return (value >= 0 and value < base)

    method to_value( Char ch ).Int32:
      # Converts the character ''ch'' into the value it represents
      # where '0'..'9' represent values 0..9 and 'a'..'z' (or
      # 'A'..'Z' represent values 10..35.
      #
      # Returns: 0..35
      if (ch >= '0' and ch <= '9') return Int32(ch - '0')
      elseIf (ch >= 'A' and ch <= 'Z') return Int32(ch - 'A') + 10
      elseIf (ch >= 'a' and ch <= 'z') return Int32(ch - 'a') + 10
      return -1

    method is_alphanumeric( Char ch ).Logical:
      # Returns "true" if ''ch'' is an alphanumeric value (0-9, a-z, 
      # A-Z).
      return is_letter(ch) or is_digit(ch)

    method hash_code( Int64   n ).Int32:
      # Returns a hash code for primitive 'n'.
      return Int32(n.right_shifted(32) ~  n)

    method hash_code( Int32   n ).Int32:
      # Returns a hash code for primitive 'n'.
      return n

    method hash_code( Real64  n ).Int32:
      # Returns a hash code for primitive 'n'.
      return hash_code( (n as Int64) )

    method hash_code( Real32  n ).Int32:
      # Returns a hash code for primitive 'n'.
      return hash_code( n as Int32 )

    method hash_code( Logical n ).Int32:
      # Returns a hash code for primitive 'n'.
      return Int32(n)

    method hash_code( Object obj ).Int32:
      # Returns "null" if the object is null or else the result of 
      # obj.hash_code.
      if (obj is null) return 0
      return obj.hash_code

    method type_name( Int64 n ).String:
      # Returns "Int64".
      return "Int64"

    method type_name( Int32 n ).String:
      # Returns "Int32".
      return "Int32"

    method type_name( Char n ).String:
      # Returns "Char".
      return "Char"

    method type_name( Byte n ).String:
      # Returns "Byte".
      return "Byte"

    method type_name( Real64 n ).String:
      # Returns "Real64".
      return "Real64"

    method type_name( Real32 n ).String:
      # Returns "Real32".
      return "Real32"

    method type_name( Logical n ).String:
      # Returns "Logical".
      return "Logical"

    requisite method requisite_kludges
      # Makes methods of certain specialized template classes requisite.
      # Not intended to ever be called.
      local Byte[] list( null.(Array<<Byte>>), false )

endClass


singleton class NumberConversions
  # Contains utility methods for converting between numbers and 
  # strings.
  METHODS
    method to_digit( Int32 n ).Char:
      # Converts the value 'n' into a representative symbol.
      #
      # Returns:
      #   One of: '0'..'9' or 'a'..'f'
      #
      # Requires:
      #   n >= 0 and n <= 15
      if (n <= 9) return Char(n + '0')
      else return Char((n - 10) + 'a')

    method is_digit( Char ch, Int32 base=10 ).Logical:
      # Returns true if the given character is a valid digit in the
      # specified number base.
      local var value = to_value(ch)
      return (value >= 0 and value < base)

    method to_value( Char ch ).Int32:
      # Converts the character ''ch'' into the value it represents.
      #
      # Returns:
      #   0..15
      #
      # Requires:
      #   ch is one of '0-9', 'a-f', or 'A-F'.
      if (ch >= '0' and ch <= '9') return Int32(ch - '0')
      elseIf (ch >= 'A' and ch <= 'Z') return Int32(ch - 'A') + 10
      elseIf (ch >= 'a' and ch <= 'z') return Int32(ch - 'a') + 10
      return -1

    method Int64_to_String( Int64 n, Int32 base, Int32 min_digits=1 ).String:
      # Converts 'n' into a string of numbers in the given number 
      # base.

      local Char[] buffer()
      local Logical is_negative = false

      # Use bit manipulation commands if the base is a power of 2
      if (base.is_power_of_two)
        # e.g. n == 16
        local Int32 bit_size = base.min_bits - 1  # e.g. 4
        local Int32 bit_mask = 1.left_shifted( bit_size ) - 1 #e.g. 0b1111
        forEach (1..min_digits)
          buffer.add( to_digit(n & bit_mask) )
          n = n.right_shifted( bit_size )
        endForEach

      else
        if (n < 0) 
          # Handle special case of e.g. -(-128) == -128
          if (n == -n) buffer.add( to_digit(base-(n%base)) ); n /= base

          is_negative = true
          n = -n
        endIf

        while (n > 9) 
          buffer.add( to_digit(n%base) )
          n /= base
        endWhile
        buffer.add( to_digit(n) )
      endIf

      while (buffer.count < min_digits) buffer.add( '0' )
      if (is_negative) buffer.add( '-' )
      buffer.reverse
      return String.create_from(buffer)


    method Real64_to_String( Real64 n, Int32 base, Int32 whole_digits=1, ...
        Int32 decimal_digits=4, Char fill_char=' ' ).String:
      # Converts 'n' into a string of numbers in the given number 
      # base.  Does not currently do any exponent notation, e.g.
      # no "6.2E7".  Supports "infinity" and "NaN" values.
      if (n == infinity)  return format_string( "infinity", whole_digits+decimal_digits+1, 0 )
      if (n == -infinity) return format_string( "-infinity", whole_digits+decimal_digits+1, 0 )
      if (n.is_NaN) return format_string( "NaN", whole_digits, 0 )

      if (decimal_digits == 0) return Int64_to_String( Int64(n), base )

      local StringBuilder result()
      local Logical is_negative = false
      if (n < 0) result.print('-'); n = -n; is_negative = true

      local Real64 shift = Real64(base) ^ decimal_digits
      n *= shift
      if (fractional_part(n) >= 0.5) n++
      n = floor( n ) / shift

      local var whole    = floor( n )
      local var fraction = fractional_part( n ) * shift
      if (fractional_part(fraction) >= 0.5) fraction++
      local var whole_st = Int64_to_String( Int64(whole), base )
      local var fraction_st = Int64_to_String( Int64(fraction), base )

      local var whole_count = whole_st.count
      if (is_negative) whole_count++

      forEach (whole_count ..< whole_digits) result.print(fill_char)
      result.print(whole_st)
      result.print('.')
      forEach (fraction_st.count ..< decimal_digits) result.print('0')
      result.print(fraction_st)

      return result.to_String

    method parse_Int64( String st, Int32 base=10 ).Int64:
      # Parses and returns an Int64 from the given string.
      #
      # The string must be well-formed in this pattern:
      #
      #   '-'? digit+
      #
      # or else an InvalidOperandError is thrown.
      if (st.count == 0) throw InvalidOperandError("st","empty string")

      local Logical is_negative, is_first=true
      local Int64   num = 0
      forEach (ch in st)
        if (ch == '-')
          if (not is_first or st.count<2) throw InvalidOperandError("st",st)
          is_negative = true
          is_first = false
          nextIteration
        elseIf (ch == '+')
          if (not is_first or st.count<2) throw InvalidOperandError("st",st)
          is_first = false
          nextIteration
        endIf
        is_first = false

        if (not is_digit(ch,base)) throw InvalidOperandError("st",st)
        num = (num * base) + to_value( ch )
      endForEach

      if (is_negative) num = -num
      return num

    method parse_Int32( String st, Int32 base=10 ).Int32:
      # Parses and returns an Int32 from the given string.
      #
      # The string must be well-formed in this pattern:
      #
      #   '-'? digit+
      #
      # or else an InvalidOperandError is thrown.
      if (st.count == 0) throw InvalidOperandError("st","empty string")

      local Logical is_negative, is_first=true
      local Int32   num = 0
      forEach (ch in st)
        if (ch == '-')
          if (not is_first or st.count<2) throw InvalidOperandError("st",st)
          is_negative = true
          is_first = false
          nextIteration
        elseIf (ch == '+')
          if (not is_first or st.count<2) throw InvalidOperandError("st",st)
          is_first = false
          nextIteration
        endIf
        is_first = false

        if (not is_digit(ch,base)) throw InvalidOperandError("st",st)
        num = (num * base) + to_value( ch )
      endForEach

      if (is_negative) num = -num
      return num

    method parse_Real64( String st ).Real64:
      # Parses and returns a Real64 from the given string.
      #
      # The string must be well-formed in this pattern:
      #
      #      '-'?  digit+  ('.' digit+)
      #   or '-'? (digit+)? '.' digit+
      #
      # or else an InvalidOperandError is thrown.
      #
      # This method does not currently support exponential 
      # notation such as "6.2E7".
      if (st.count == 0) throw InvalidOperandError("st","empty string")

      local var e_index = st.index_of('e')
      if (e_index == -1) e_index = st.index_of('E')
      if (e_index >= 0)
        local var base_value = parse_Real64(st.before(e_index))
        local var exponent = parse_Real64(st.after(e_index))
        return base_value * (10.0^exponent)
      endIf

      local Logical is_negative = false
      if (st[0] == '-')
        is_negative = true
        st = st.substring(1)
      endIf

      if (st.index_of('-') >= 0) throw InvalidOperandError("st: $" (st))

      # Find or add on the decimal point and add on at least one 
      # digit on each side.
      local var decimal = st.index_of( '.' )
      if (decimal == -1) st += ".0"
      elseIf (decimal == 0) st = "0" + st
      decimal = st.index_of( '.' )

      local String left = st.substring( 0, decimal-1 )
      local String right = st.substring( decimal+1 )

      local Real64 dec = 0.0
      forEach (ch in right.reversed) dec = (dec + to_value(ch)) / 10.0

      local Real64 w = 0.0
      forEach (ch in left) w = w * 10 + to_value(ch)

      local Real64 r = w + dec
      if (is_negative) r = -r

      return r
endClass

#=====================================================================
# Error classes
#=====================================================================
requisite class StackTrace
  PROPERTIES
    history   : Int64[]

  METHODS
    method init
      local var h = native_history
      if (h?) history = Int64[]( h )

    requisite method init( Array<<Int64>> record ):
      history = Int64[]( record )

    requisite method to_String.String:
      return to_String(false)

    method cull
      # Removes any history entries containing Exception method calls
      forEach (ip in history)
        local String description = describe(ip)
        if (description.contains("Exception::")) removeCurrent ip
        elseIf (description.contains("Error::")) removeCurrent ip
        elseIf (description.contains("StackTrace::")) removeCurrent ip
      endForEach

    method to_String( Logical full_trace ).String:
      if (history is null) return "[compiled code]"
      local StackTraceInfo[] call_info(history.count)
      forEach (ip in history)
        local String description = describe(ip)
        local StackTraceInfo info()
        if (description.contains('@'))
          local var numst = description.before_first('@')
          info.line = numst.to_Int32
          info.filename = description.after_first('@').before_first('|')
          info.method_name = description.after_first('|')
          if (not full_trace)
            if (info.method_name.contains("StackTrace::")) nextIteration
            if (info.method_name.contains("Exception::")) nextIteration
            if (info.method_name.contains("Error::")) nextIteration
          endIf
        else
          info.method_name = description
        endIf
        call_info.add(info)
      endForEach

      while (call_info.count > 1 and call_info.last.filename is null) call_info.remove_last

      local StringBuilder buffer()

      local var count = call_info.count
      if (count <= 11 or full_trace)
        forEach (info in call_info) buffer.println(info)
      elseIf (count <= 21)
        forEach (i in 0..9) buffer.println(call_info[i])
        buffer.println( "  ... [$ more]" (count-10) )
      else
        forEach (i in 0..9) buffer.println(call_info[i])
        buffer.println( "  ... [$ more]" (count-20) )
        forEach (i in count-10..count-1) buffer.println(call_info[i])
      endIf
      return buffer.to_String

    method native_history.Array<<Int64>>: native

    method describe( Int64 ip ).String: native

endClass

class StackTraceInfo()
  PROPERTIES
    method_name, filename : String
    line : Int32

  METHODS
    method to_String.String:
      if (filename is null) return "  " + method_name
      return //  $ at "$" line $// (method_name,filename,line)
endClass

requisite abstract class Exception
  # The base class of all Error messages.  An 'Exception' in Slag is
  # equivalent to a RuntimeException in Java; there are no checked
  # exceptions that require a try/catch block or a 'throws'
  # clause.  Most subclasses of Exception are derived from child class
  # 'Error'.
  PROPERTIES
    message : String 
      # The error message.

    stack_trace() : StackTrace

  METHODS
    method init_object:
      if (stack_trace is null)
        # The stack trace can be set by the native layer.
        stack_trace = StackTrace()
      endIf

    requisite method init:
      # Sets the error message to an empty string.
      message = ""

    method init( message ):
      # Stores the given error message.

    method to_String.String:
      # Returns a description of the execution IP at the time
      # the error was thrown along with the error message.
      return "$: $\n$" (type_name,message,stack_trace)

    method to_String( Logical full_trace ).String:
      # Returns a description of the execution IP at the time
      # the error was thrown along with the error message.
      return "$: $\n$" (type_name,message,stack_trace.to_String(full_trace))
endClass

class Error : Exception
  # All built-in exceptions are extended from this Error class.
  METHODS
    method init_object:

    requisite method init:
      # Sets the error message to an empty string.
      message = ""

    method init( message ):
      # Stores the given error message.
endClass

requisite class TypeCastError : Error
  # Error subclass for typecast errors.  Thrown when an object is
  # cast to type without being instanceOf that type.
  METHODS
    requisite method init:
      message = "Invalid type cast."

    method init( message ):
      # Stores the given error message.
endClass

requisite class MissingReturnError : Error
  # The Slag VM program loader appends a 'throw MissingReturnError()'
  # command to the end of every method.  If the programmer forgets
  # or if an exploit omits the 'return' value then the program will
  # fail with an exception once it reaches that point.
  METHODS
    requisite method init:
      message = "'return' command missing."

    method init( message ):
      # Stores the given error message.
endClass

requisite class NoSuchElementError : Error
  # Thrown by HashTable (at least) when it is queried for the value
  # corresponding to a non-existent key.
  METHODS
    requisite method init: 
      # Default initializer.
      message = "No such element."

    requisite method init( String element_name ): 
      # Creates a custom error message which incorporates the 
      # element_name. 
      message = //No such element: "$".// (element_name)
endClass

requisite class NullReferenceError : Error
  METHODS
    requisite method init:
      # Default initializer.
      message = "Attempted access to an object member using a null reference."

    method init( message ):
endClass

requisite class NoNextValueError : Error
  # Thrown when 'peek' or 'read' is called on a Reader and there is
  # no next value.
  METHODS
    requisite method init:
      # Default initializer.
      message = "Reader has no next value to return."

    method init( message ):
      # Stores the given error message.
endClass

requisite class UnsupportedMethodError : Error
  # Thrown when an "optional" method is called on an object that 
  # doesn't implement that optional method.
  METHODS
    requisite method init:
      # Default initializer.
      message = "This object does not support this functionality:"

    method init( message ):
      # Stores the given error message.
endClass

class UnsupportedOperationError : Error
  # Thrown when a native layer command (such as System.execute) is not
  # supported.
  METHODS
    requisite method init:
      # Default initializer.
      message = "The current native layer does not support this functionality:"

    method init( message ):
      # Stores the given error message.
endClass

requisite class CallStackLimitReached : Error
  # Thrown when the runtime runs out of stack space.
  METHODS
    requisite method init( Array<<Int64>> history ):
      stack_trace = StackTrace(history)
      message = "Too many recursive calls have been made."
endClass

requisite class InvalidOperandError : Error
  # Thrown by a method when it identifies one of its parameters
  # as having an invalid value.
  METHODS
    requisite method init:
      # Default initializer.
      message = "Illegal operand value."

    method init( String var_name ):
      # This initializer incorporates the given var_name into the
      # error message.
      message = "Illegal operand value for $." (var_name)

    method init( String var_name, String var_value ):
      # This initializer incorporates the given var_name and the
      # given illegal value into the error message.
      message = "Illegal operand value ($) for $." (var_value,var_name)
endClass


requisite class OutOfBoundsError : Error
  # Thrown when an element request uses an invalid index.
  METHODS
    requisite method init:
      # Default initializer.
      message = "List or array index out of bounds."

    method init( Int32 index ):
      # This initializer incorporates the given index into the
      # error message.
      message = "Out of bounds access at index $." (index)

    method init( message ):
      # Stores the given error message.
endClass

class ConcurrentModificationError : Error
  # Thrown when a reader detects that other code has modified a list
  # between one read and the next.
  METHODS
    requisite method init:
      # Default initializer.
      message = "Concurrent modification error - list structure has changed during iteration."

    method init( message ):
      # Stores the given error message.
endClass

requisite class FileError : Error
  METHODS
    requisite method init:
      # Default initializer.
      message = "Error accessing file."

    requisite method init( String filename ):
      message = //Error accessing "$".// (filename)
endClass

requisite class FileNotFoundError : FileError
  METHODS
    requisite method init:
      # Stores the given error message.
      message = "Error accessing file."

    requisite method init( String filename ):
      # Stores the given error message.
      message = //Error accessing "$".// (filename)
endClass

requisite class SocketError : Error
  METHODS
    requisite method init:
      # Default initializer.
      message = "Error during socket I/O."

    method init( message ):
      # Stores the given error message.
endClass


requisite class DivideByZeroError : Error
  METHODS
    requisite method init:
      # Default initializer.
      message = "Integer division by zero!"

    method init( message ):
      # Initializes this Error with the given message.
endClass


requisite class InvalidStateError : Error
  METHODS
    requisite method init:
      # Default initializer.
      message = "The call context does not support this method in its current state."

    method init( message ):
      # Stores the given error message.
endClass


#=====================================================================
#  Array classes
#=====================================================================
requisite class GenericArray
  # Defines methods common to all arrays.
  METHODS
    method count.Int32: native
      # Returns the count of how many elements are in this array.

    method copy_from( GenericArray src_array, Int32 src_index, Int32 dest_index, Int32 number ): native
      # Copies 'number' elements from another array (starting at
      # element 'src_index') into this one (starting at element
      # 'dest_index').
      #
      # Elements may be copied within overlapping regions of the same array.

    method clear( Int32 first_index, Int32 last_index  ): native
      # Clears all the elements in this array between the two indices.
      #
      # Using this method to clear elements at the end of an arraylist
      # allows the runtime to limit the number of reference array 
      # elements it searches through during a garbage collection.
      #
      # Technical note: the runtime tracks the furthest position that 
      # a non-null reference array element could possibly be at after 
      # various calls to clear() and set().
endClass

class Array<<$DataType>> : GenericArray
  # Primarily for internal use - in most cases use ArrayList instead.
  #
  # Array is a placeholder type.  Arrays are actually implemented 
  # in the runtime implementation; calls to array methods are intercepted 
  # by the program loader and translated into array-related opcodes.
  #
  # To get an array in Slag you must be explicit, e.g. "Array<<Int32>>(20)".  
  # The notation "Int32[] nums(20)" generates ArrayLists instead.
  #
  # Arrays are not covariant as they are in Java.  An Array<<String>>
  # counts as an Object but not as an Array<<Object>>.

  METHODS
    method init( Int32 size ): native
      # Sets up this array to contain the given number of elements.
      #
      # The call to this method is intercepted by the compiler
      # and transformed into a native-layer array operation.

    method get( Int32 index ).$DataType: native
      # Retieves the element at the zero-based 'index'.
      #
      # 'index' should be between 0 and count-1.
      #
      # The call to this method is intercepted by the compiler
      # and transformed into a native-layer array operation.

    method set( Int32 index, $DataType value ): native
      # Sets the element at the zero-based 'index' to the new 'value'.
      #
      # 'index' should be between 0 and count-1.
      #
      # The call to this method is intercepted by the compiler
      # and transformed into a native-layer array operation.

    method create_duplicate.Array<<$DataType>>:
      # Creates a duplicate of this array when the "duplicate(array)"
      # command is given.  If the array element type is a reference 
      # type, the new array contains a copy of the same references
      # to the same objects - the objects themeselves are not 
      # duplicated.
      local Array<<$DataType>> dupe( count )
      dupe.copy_from( this, 0, 0, count )
      return dupe
endClass



#=====================================================================
#  Array, List, and ArrayList classes
#=====================================================================
requisite aspect ListType;
  # Placeholder aspect that provides a common base type for all
  # List<<$DataType>> classes.

aspect Collection<<$DataType>>
  # Miscellaneous read method definitions common to both List and 
  # String.
  METHODS
    method count.Int32: abstract
      # Returns the number of elements in this collection (>=0).

    method modification_count.Int32: return 0
      # Returns the number of times this data structure has had an 
      # element added to or removed from it.

    method first.$DataType:
      # Returns the first element of this data.  This convenience
      # method is equivalent to get(0).
      return get(0)

    method last.$DataType:
      # Returns the last element of this data.  This convenience
      # method is equivalent to get(count-1).
      return get(count-1)

    method end( Int32 from_end ).$DataType:
      # Equivalent to get( (count-1) + from_end ).
      #
      # For example, end(0) is equivalent to last() and
      # end(-1) is equivalent to get(count-2).
      return get((count-1) + from_end)

    method random.$DataType:
      # Returns an element of this data at random.
      return get( random_Int32(0,count-1) )

    method random_index.Int32:
      # Returns the index of a randomly selected element.
      return random_Int32(0,count-1)

    method index_of( $DataType value, Int32 starting_index=0 ).Int32:
      # Returns the first index that the given value occurs at
      # starting at index 0 by default.  (-1) is returned if
      # 'value' is not found.
      forEach (i in starting_index ..< count) 
        if (get(i) == value) return i
      endForEach
      return -1

    method last_index_of( $DataType value, Int32 starting_index=-1 ).Int32:
      # Returns the last index that the given value occurs at
      # starting at index (count-1) by default.  (-1) is 
      # returned if 'value' is not found.
      if (starting_index == -1) starting_index = count-1
      forEach (index in starting_index downTo 0)
        if (this[index] == value) return index
      endForEach
      return -1

    method contains( $DataType value ).Logical:
      # Returns "true" if this data contains the given value.
      return index_of(value) >= 0

    method indices.Range<<Int32>>:
      # Returns this data's range of indices (0..count-1).
      return (0 ..< count)

    method reverse_indices.Range<<Int32>>:
      # Returns this data's range of indices reversed (count-1 downTo 0).
      #
      # Example:
      #   local Int32[] nums = {5..7}
      #   forEach (i in nums.reverse_indices) println( i )
      #     # prints: 2 | 1 | 0
      return (count-1 downTo 0)

endAspect

underlying aspect List<<$DataType>> : ListType, Collection<<$DataType>>, Readable<<$DataType>>
  # A List aspect is an ordered collection that is Readable and
  # addressable by index.
  #
  # Numerical lists incorporate the ListOrdering<<$DataType>> aspect.

  METHODS
    method count.Int32:    abstract
      # Returns the number of elements in this list.  
      # This will be zero or higher.

    method modification_count.Int32: abstract
      # Returns the number of times this list has had an element added to
      # or removed from it.

    method get( Int32 index ).$DataType: abstract

    method set( Int32 index, $DataType value):    abstract
      # Sets the element at the zero-based 'index' to be 'value'.
      #
      # Note that the compiler translates all calls of the form:
      #   a[i] = v
      #
      # into:
      #   a.set(i,v)
      #
      # Requires:
      #   0 <= index < count

    method clear: abstract
      # Removes all values from this list.

    method swap( Int32 index_a, Int32 index_b ):
      # Swaps the value at 'index_a' with the one at 'index_b'.
      #
      # Requires:
      #   0 <= index_a < count
      #   0 <= index_b < count
      #
      # Invariant:
      #   this[index_a] = old[index_b]
      #   this[index_b] = old[index_a]
      local var temp = get(index_a)
      set( index_a, get(index_b) )
      set( index_b, temp )

    method create_reader.Reader<<$DataType>>:
      # Returns a reader that can be used to read() this data one 
      # element at a time.
      return ListReader<<$DataType>>( this, 0 )

endAspect

underlying aspect ListOperations<<$DataType,$CollectionType>> : List<<$DataType>>
  # A List aspect is an ordered collection that is Readable and
  # addressable by index.
  #
  # Numerical lists incorporate the ListOrdering<<$DataType>> aspect.

  METHODS
    method ensure_capacity( Int32 desired_capacity ):
      # Directs a list to prepare itself to hold a total of
      # 'desired_capacity' elements.  Proper use prevents ArrayLists
      # from having to resize their data structures multiple times 
      # over the course of an operation.

    requisite method ensure_count( Int32 num_items ):
      # Increases the size of this list by enough null/zero items
      # so that its count is at least 'num_items'.
      #
      # Default implementation.
      local $DataType empty_item
      ensure_capacity( num_items )
      while (count < num_items) add( empty_item )

    method is_empty.Logical:
      return count == 0

    method get( Range<<Int32>> range ).$CollectionType:
      if (range.is_contiguous_ascending)
        return subset( range.first, range.last )
      else
        throw InvalidOperandError("range")
      endIf

    method add( $DataType value ).$CollectionType:
      # Appends 'value' to the end of this list.
      #
      # Returns a reference to this list for call-chaining, e.g.:
      #
      #   list.add(3).add(4).add(5)
      #
      # Invariant: 
      #   new.count == old.count + 1
      #   new.last is value
      return insert( value, count )

    method add( $DataType value, Int32 after_index ).$CollectionType: 
      # Inserts 'value' after the given index.
      #
      # Returns:
      #   A reference to this list for call-chaining.
      #
      # Requires: 
      #   after_index >= -1 and after_index < count
      #
      # Invariant: 
      #   new.count          == old.count + 1
      #   new[after_index+1] == value
      return insert( value, after_index + 1 )

    method add( Readable<<$DataType>> source ).$CollectionType:
      # Adds each item from the Readable source to this list.
      #
      # Returns a reference to this list for call-chaining.
        forEach (value in source) add( value )
      return this

    method insert( $DataType value, Int32 before_index=0 ).$CollectionType: abstract
      # Inserts the given value into the list just before the given 
      # index.
      #
      # Returns a reference to this list for call-chaining.
      #
      # Requires: 
      #   before_index >= 0 and before_index <= count

    method insert( List<<$DataType>> seq, Int32 before_index=0 ).$CollectionType:
      # Inserts all the given values in front of 'before_index'.  Elements
      # at 'begin_index' and higher are logically shifted up by one.
      #
      # Returns:
      #   A reference to this list for call chaining.
      # 
      # Requires: 
      #   0 <= before_index and before_index <= count
      #
      # Invariant:
      #   this[before_index]   = value
      #   this[before_index+seq.count] = old[before_index]
      #   count = old.count + seq.count

      # naive default implementation
      forEach (value in seq)
        insert( value, before_index )
        before_index++
      endForEach
      return this

    method copy_from( Readable<<$DataType>> source ).$CollectionType:
      # Equivalent to:
      #   list.clear
      #   list.add( source )
      clear
      add( source )
      return this

    method transfer_from( List<<$DataType>> source ).$CollectionType:
      # Equivalent to:
      #   list.clear
      #   list.add( source )
      #   source.clear
      clear
      add( source )
      source.clear
      return this

    method remove( Int32 index ).$DataType: abstract
      # Removes and returns the element at the given index.  Elements
      # above 'index' are each shifted down by one space.
      #
      # Invariant:
      #   new.count = old.count - 1
      #   result == old[index]
      #   new[i] == old[i+1] for all index <= i <= new.count

    method remove( Int32 first_index, Int32 last_index ).$CollectionType:
      # Removes and returns the elements in the specified range.
      # See discard() for a variant that's optimal when you don't
      # need the return value.
      #
      # 'first' and 'last' are clipped to be a valid range. 
      #
      # Returns:
      #   The list of elements from old[first] through old[last].
      #
      # This default implementation is non-optimal.
      local $CollectionType results(last_index-first_index+1)
      forEach (index in first_index..last_index) results.add( this[index] )
      forEach (index in last_index downTo first_index) remove(index)
      return results

    method remove_first.$DataType:
      # Equivalent to:
      #   list.remove(0)
      return remove(0)

    method remove_last.$DataType:
      # Equivalent to:
      #   list.remove(list.count-1)
      return remove(count-1)

    method remove_random.$DataType:
      # Removes and returns an element of this data at random.
      return remove(random_index)

    method remove_value( $DataType value ).Logical:
      # Removes the first occurrence of 'value' from the list.
      #
      # Returns:
      #   "true" if an occurrence of 'value' was found
      #   and removed, or "false" if it was not found.
      #
      # Technical note: this method can't be named remove() because 
      # in an Int32[] list, remove(index) and remove(value) would 
      # have the same signature.
      local Int32 index = index_of( value )
      if (index == -1) return false
      remove( index )
      return true

    method discard_from( Int32 first_index ):
      # Removes all elements from index 'first' to the end.
      discard( first_index, count-1 )

    method discard( Int32 first_index, Int32 last_index ):
      # Removes the elements in the specified range.  Does not return
      # the list of removed elements like remove() does.  If only
      # the 'first' parameter is given, elements from 'first' to the
      # end of the list are discarded.
      #
      # 'first' and 'last' are clipped to be a valid range. 
      #
      # This default implementation is non-optimal.
      if (first_index < 0) first_index = 0
      forEach (index in last_index downTo first_index) remove( index )

    method discard( Range<<Int32>> range ):
      # Removes elements in the specified range.
      #
      # Requires: range.is_contiguous_ascending
      if (not range.is_contiguous_ascending)
        throw InvalidOperandError("range")
      endIf
      discard( range.first, range.last )

    method discard_first:
      # Removes the first element in the list without returning it.
      #
      # This default implementation is non-optimal.
      remove(0)

    method discard_last:
      # Removes the last element in the list without returning it.
      remove(count-1)

    method discard_first( Int32 n ):
      # Removes 'n' elements from the front of the list.  Does not
      # return the list of removed elements like remove() does.
      #
      # This default implementation is non-optimal.
      forEach (1..n) remove_first

    method discard_last( Int32 n ):
      # Removes 'n' elements from the end of the list.  Does not
      # return the list of removed elements like remove() does.
      #
      # This default implementation is non-optimal.
      forEach (1..n) discard_last

    requisite method clear:
      # Removes all the items in this list.
      #
      # Invariant:
      #   new.count = 0
      #   new.capacity == old.capacity
      #
      # This default implementation is non-optimal
      forEach (index in count-1 downTo 0) remove( index )

    method create_duplicate.$CollectionType:
      # Creates and returns a new list containing all the items
      # in this list.
      #
      # Called indirectly in response to: duplicate(list)
      #
      # When used with references, note that this method does not 
      # duplicate the objects in the list but just the list
      # data structure itself (a shallow copy).
      local $CollectionType dup(count)
      forEach (element in this) dup.add( element )
      return dup

    method from( Int32 starting_index ).Reader<<$DataType>>:
      # Returns a reader that can be used to read() this data one 
      # element at a time with the given 'starting_index'.
      return ListReader<<$DataType>>( this, starting_index )

    method from( Range<<Int32>> range ).Reader<<$DataType>>:
      # Returns a reader that can be used to read() this data one 
      # element at a time from the given starting index up to and
      # including the ending index.
      if (not range.is_contiguous_ascending)
        throw InvalidOperandError("range")
      endIf
      local Int32 first_i = range.first
      local Int32 n = (range.last - first_i) + 1
      return ListReader<<$DataType>>( this, first_i, n )

    method reverse_order.Reader<<$DataType>>:
      # Returns a reader that can be used to read() this data one 
      # element at a time from the last element (N-1) to the first (0).
      return IndexedDataReverseReader<<$DataType>>( this )

    method format( String prefix, String prepeat, String suffix ).String:
      # Converts this list into a string using the following format:
      #
      #   prefix + $0 + [prepeat + $N]* + suffix
      #
      # where "$0" is the first element and $N is every other element.
      #
      # Example:
      #
      #   local Int32[] nums = 11..15
      #   println( nums.to_String("[", "+", "]") )
      #   # prints: [11+12+13+14+15]
      local StringBuilder buffer()
      buffer.print( prefix )
      if (count?) buffer.print( this[0] )
      forEach (n in this.from(1)) buffer.print( "$()$" (prepeat,n) )
      buffer.print( suffix )
      return buffer.to_String

    method format( String str_format, String repeater_chars="[]" ).String:
      # Easier convenience method to accomplish to_String(prefix,prepeat,suffix).
      #
      # Breaks down a simple format like this:
      #
      #   {$[ or $]}
      #
      # Into a prefix="{", prepeat=" or ", suffix="}".
      #
      # Normally "[]" brackets are used to denote the repeater portion,
      # but this may be specified otherwise.
      #
      # Example:
      #
      #   local Int32[] nums = 11..15
      #   println( nums.to_String( "[$:+$:]", ":" )
      #   # prints: [11+12+13+14+15]
      #
      #   println( nums.to_String( "{$[,$]}" )
      #   # prints: {11,12,13,14,15}
      local Int32 r1=0, r2=str_format.count-1
      while (r1 < r2)
        if (repeater_chars.contains(str_format[r1])) escapeWhile
        r1++
      endWhile
      while (r2 > 0)
        if (repeater_chars.contains(str_format[r2])) escapeWhile
        r2--
      endWhile
      if (str_format[r1-1] != '$') throw InvalidOperandError("str_format")
      if (str_format[r2-1] != '$') throw InvalidOperandError("str_format")
      local var prefix = str_format.leftmost(r1-1)
      local var suffix = str_format.substring(r2+1)
      str_format = str_format.substring(r1+1,r2-1)
      local var prepeat = str_format.excluding_rightmost(1)
      return format( prefix, prepeat, suffix )

    method subset( Int32 first_index, Int32 last_index ).$CollectionType:
      # Returns the subset of this data between indices 
      # [first_index,last_index] inclusive.
      local ArrayList<<$DataType>> seq( last_index - first_index )
      forEach (i in first_index..last_index) seq.add( get(i) )
      return seq

    method shuffle:
      # Swaps every element of this data with another element at a
      # randomly-chosen position.
      local var limit = count
      forEach (i of this)
        swap( i, random_Int32(limit) )
      endForEach

    method shuffled.$CollectionType:
      # Returns a shuffled copy of this data.
      local var dupe = duplicate( this )
      dupe.shuffle
      return dupe

    method reverse:
      # Reverses the order of the elements in this data.
      local var i=0, j=count-1
      while (i <= j)
        swap(i,j)
        i++
        j--
      endWhile

    method reversed.$CollectionType:
      # Returns an list containing the elements of this data 
      # in reverse order.
      local var dupe = duplicate( this )
      dupe.reverse
      return dupe

    method to_String.String:
      # Returns a string representation of this data.
      local StringBuilder builder( count * 4 )
      builder.print( '{' )
      forEach (i of this)
        if (i > 0) builder.print( ',' )
        builder.print( to_String(this[i]) )
      endForEach
      builder.print( '}' )
      return builder.to_String
endAspect


underlying aspect ListOrdering<<$DataType>>
  # Defines arithmetic operations involving lists.
  METHODS
    method sum.$DataType:
      # Returns the sum of all the values contained in this list.
      #
      # Only implemented for numerical list types.
      local $DataType s = 0
      forEach (value in this) s += value
      return s

    method product.$DataType:
      # Returns the product of all the values contained in this list.
      #
      # Only implemented for numerical list types.
      local $DataType p = 1
      forEach (value in this) p *= value
      return p

    method min.$DataType:
      # Returns the lowest value in this list.
      local var lowest = this[0]
      forEach (value in this.from(1))
        if (value < lowest) lowest = value
      endForEach
      return lowest

    method max.$DataType:
      # Returns the highest value in this list.
      local var highest = this[0]
      forEach (value in this.from(1))
        if (value > highest) highest = value
      endForEach
      return highest

    method sort( Sort order ):
      # Call list.sort(Sort.ascending) or list.sort(Sort.descending).
      if (order is Sort.ascending) sort( CompareFn<<$DataType, a < b>>() )
      else                         sort( CompareFn<<$DataType, a > b>>() )

    method sort( Comparator<<$DataType>> comparator=null ):
      # Sorts this list in place using a HeapSort.
      #
      # 'order' is Sort.ascending by default.
      #
      # 'comparator' is an optional functor that compares two 
      # values (a,b) and "true" if 'a' should come before 'b'.
      #
      # Only implemented for numerical and String lists.  To
      # enable it for lists of other types (say,Signal), add
      # this augment:
      #   augment List<<Signal>>
      #     METHODS
      #       method sort( Comparator comparator=null ):
      #         HeapSort<<$DataType>>.sort( this, order )
      #   endAugment
      HeapSort<<$DataType>>.sort( this, comparator )

    method sorted( Sort order ).List<<$DataType>>:
      # Call list.sorted(Sort.ascending) or list.sorted(Sort.descending).
      if (order is Sort.ascending) return sorted( CompareFn<<$DataType, a < b>>() )
      else                         return sorted( CompareFn<<$DataType, a > b>>() )

    method sorted( Comparator<<$DataType>> comparator=null ).List<<$DataType>>:
      # Returns an list containing the elements of this data 
      # sorted into order.  Only implemented for numerical and
      # String lists.
      #
      # 'comparator' is an optional functor that compares two 
      # values (a,b) and "true" if 'a' should come before 'b'.
      local var result = duplicate(this)
      result.sort(comparator)
      return result
endAspect

augment List<<numerical>> : ListOrdering<<$DataType>>;

augment List<<non-numerical>>
  METHODS
    method remove( $DataType value ).Logical:
      # Calls remove_value(value).  Only available for non-numerical
      # lists - see note in remove_value().
      return remove_value( value )
endAugment


overlaying augment List<<String>>
  METHODS
    method sort( Comparator<<String>> comparator=null ):
      # Sorts this list in place using a HeapSort.
      #
      # 'comparator' is an optional functor that compares two 
      # values (a,b) and "true" if 'a' should come before 'b'.
      HeapSort<<String>>.sort( this, comparator )

    method sorted( Comparator<<String>> comparator=null ).List<<String>>:
      # Returns an list containing the elements of this data 
      # sorted into order.  Only implemented for numerical and
      # String lists.
      #
      # 'comparator' is an optional functor that compares two 
      # values (a,b) and "true" if 'a' should come before 'b'.
      local var result = duplicate(this)
      result.sort(comparator)
      return result

    method sort( Sort order ):
      # Call list.sort(Sort.ascending) or list.sort(Sort.descending).
      if (order is Sort.ascending) sort( CompareFn<<String, a < b>>() )
      else                         sort( CompareFn<<String, a > b>>() )

    method sorted( Sort order ).List<<String>>:
      # Call list.sorted(Sort.ascending) or list.sorted(Sort.descending).
      if (order is Sort.ascending) return sorted( CompareFn<<String, a < b>>() )
      else                         return sorted( CompareFn<<String, a > b>>() )

    method join( String joiner="\n" ).String:
      # Joins the strings in this string list together, concatenating 'joiner'
      # in-between each original string (but not after the last string).
      local StringBuilder buffer(first)
      forEach (st in this.from(1))
        buffer.print(joiner)
        buffer.print(st)
      endForEach
      return buffer.to_String

    method to_String.String:
      return format("$[\n$]")

endAugment


class ArrayList<<$DataType>> : ListOperations<<$DataType,ArrayList<<$DataType>>>>
  # The most common "collection" type in Slag, an ArrayList is an
  # indexable list of items implemented using arrays.
  #
  # An array list has 'count' and 'capacity'.  Capacity is how many
  # elements an arraylist can store before it has to create a larger
  # backing array.  Count is how many elements of the current array
  # are currently in use.  When 'count' reaches 'capacity', the next
  # add() operation causes the backing array to be doubled in size.
  #
  # An arraylist starts out at capacity 10, count 0 by default.
  #
  # When you use "array notation" in Slag it creates arraylists.
  # The following convenience conversions are performed:
  #
  #   # Create an empty list with 10 capacity
  #   Int32[] nums(10)  # 10 capacity
  #     -> List<<Int32>> nums = ArrayList<<Int32>>(10)
  #
  #   # Create a list of 10 zero/null values
  #   Int32[] nums = Int32[10]
  #     -> List<<Int32>> nums = ArrayList<<Int32>>( 10, 0 )
  #   
  #   # Create a list with the numbers 1 to 3
  #   Int32[] nums = { 1, 2, 3 }
  #     -> List<<Int32>> nums = ...
  #            ArrayList<<Int32>>().add(1).add(2).add(3)
  #
  # Invariant:
  #   count >= 0
  #   capacity >= count
  #   data.count == capacity
  PROPERTIES
    data  : Array<<$DataType>>
      # The backing array for this arraylist.

    count   : Int32
      # The position to add the next item - also equivalent to the 
      # used item count.

    modification_count : Int32
      # The number of times this list has had an element added to or removed from it.

  METHODS
    method init: 
      # Creates an empty arraylist of capacity 10.
      init( 10 )

    method init( Int32 initial_capacity ):
      # Creates an empty arraylist with a specified initial capacity.
      if (initial_capacity < 0) throw InvalidOperandError("initial_capacity","$"(initial_capacity))
      data = Array<<$DataType>>( initial_capacity )

    method init( Int32 initial_capacity, $DataType content ):
      # Creates an array list full of 'initial_capacity' duplicates of
      # the given 'content'.
      init( initial_capacity )
      forEach ( 1..initial_capacity ) 
        add( duplicate(content) )
      endForEach

    method init( Array<<$DataType>> array, Logical make_copy=true ):
      # Initializes this list to contain a copy of all the numbers
      # in the given array (if 'make_copy' is true) or else use the
      # given array as the actual list data.
      if (make_copy) data = duplicate(array)
      else data = array
      count = array.count

    method init( Readable<<$DataType>> readable ):
      # Initializes this list to contain all the items from the
      # 'readable' data source.
      init
      add( readable )

    method create_reader.ArrayReader<<$DataType>>:
      # Returns a reader that can be used to read() this data one 
      # element at a time.
      return ArrayReader<<$DataType>>( this, data, 0, count )

    method from( Int32 starting_index ).ArrayReader<<$DataType>>:
      # Returns a reader that can be used to read() this data one 
      # element at a time with the given 'starting_index'.
      return ArrayReader<<$DataType>>( this, data, starting_index, count-starting_index )

    method from( Range<<Int32>> range ).ArrayReader<<$DataType>>:
      # Returns a reader that can be used to read() this data one 
      # element at a time from the given starting index up to and
      # including the ending index.
      if (not range.is_contiguous_ascending)
        throw InvalidOperandError("range")
      endIf
      local Int32 first_i = range.first
      local Int32 n = (range.last - first_i) + 1
      return ArrayReader<<$DataType>>( this, data, first_i, n )

    method reverse_order.ArrayReader<<$DataType>>:
      # Returns a reader that can be used to read() this data one 
      # element at a time from the last element (N-1) to the first (0).
      return ArrayReverseReader<<$DataType>>( this, data )

    generic method count.Int32:
      # Returns how many values there are in this list.
      return &count

    generic method modification_count.Int32:
      # Returns the number of times this list has had an element added to
      # or removed from it.
      return &modification_count

    generic method capacity.Int32:
      # Returns how many values this list can store before its backing
      # array must be doubled in size.
      return data.count

    generic method ensure_capacity( Int32 min_capacity ):
      # Effects that this list has a capacity of at least 
      # 'min_capacity'.  If it has a lower capacity, the backing
      # array is reallocated to have the necessary capacity.
      if (capacity < min_capacity)
        local Array<<$DataType>> new_data( min_capacity )
        new_data.copy_from( data, 0, 0, &count )
        data = new_data
      endIf

    requisite generic method ensure_count( Int32 num_items ):
      # Increases the size of this list by enough null/zero items
      # so that its count is at least 'num_items'.
      ensure_capacity( num_items )
      if (num_items > &count)
        &count = num_items
        ++modification_count
      endIf

    generic method get( Int32 index ).$DataType:
      # Returns the element at the given zero-based index.
      #
      # Requires:
      #   0 <= index and index < count

      # Index may be within the bounds of the backing array but
      # out of bounds for the arraylist.
      return data[index]

    generic method set( Int32 index, $DataType value ):
      # Sets the element at the given zero-based index.
      #
      # Requires:
      #   0 <= index and index < count

      # Index may be within the bounds of the backing array but
      # out of bounds for the arraylist.
      data[index] = value

    requisite generic method add( $DataType value ).$DataType[]:
      # Adds the given 'value' to the end of this list.
      #
      # Returns a reference to this list for call chaining.
      #
      # Invariant:
      #   count = old.count + 1
      #   get[count-1] == value
      if (&count == data.count) 
        if (&count == 0) ensure_capacity( 1 )
        else ensure_capacity( data.count * 2 )
      endIf
      data[&count] = value
      ++&count
      ++modification_count
      return this


    generic method insert( $DataType value, Int32 before_index=0 ).$DataType[]:
      # Inserts the 'value' in front of 'before_index'.  Elements
      # at 'begin_index' and higher are shifted over by one.
      #
      # Returns:
      #   A reference to this list for call chaining.
      # 
      # Requires: 
      #   0 <= before_index and before_index <= count
      #
      # Invariant:
      #   this[before_index]   = value
      #   this[before_index+1] = old[before_index]
      #   count = old.count + 1
      add( value )  # let add() take care of making room for one more.
      data.copy_from( data, before_index, before_index+1, 
        &count - (before_index+1) )  # minus (b4+1) since count has already increased
      data[before_index] = value
      return this


    generic method insert( List<<$DataType>> seq, Int32 before_index=0 ).$DataType[]:
      # Inserts all the given values in front of 'before_index'.  Elements
      # at 'begin_index' and higher are shifted over by one.
      #
      # Returns:
      #   A reference to this list for call chaining.
      # 
      # Requires: 
      #   0 <= before_index and before_index <= count
      #
      # Invariant:
      #   this[before_index]   = value
      #   this[before_index+seq.count] = old[before_index]
      #   count = old.count + seq.count

      local var gap = seq.count
      if (gap == 0) return this

      ensure_capacity( &count + gap )
      data.copy_from( data, before_index, before_index+gap, &count - before_index )
      forEach (i of seq) data[before_index+i] = seq[i]
      &count += gap
      ++modification_count
      return this

    generic method remove( Int32 index ).$DataType:
      # Removes and returns the element at position 'index'.  All
      # elements higher than 'index' are shifted down by one spot
      # and the list count is decremented.
      #
      # Returns:
      #   old[index]
      #
      # Requires 0 <= ''index'' and ''index'' < ''count''.
      # 
      # Invariant:
      #   new[index] = old[index+1]
      # 
      if (index >= count) throw InvalidOperandError("index","$"(index))
      local var result = data[index]
      &count--
      ++modification_count
      data.copy_from( data, index+1, index, &count-index )
      data.clear( &count, &count )
      return result

    generic method remove( Int32 first_index, Int32 last_index ).$DataType[]:
      # Removes and returns the elements in the specified range.
      #
      # 'first' and 'last' are clipped to be a valid range. 
      #
      # Returns:
      #   The list of elements from old[first] through old[last].
      if (first_index < 0) first_index = 0
      if (last_index >= count) last_index = count - 1

      local var len = (last_index - first_index) + 1

      if (len <= 0) return ArrayList<<$DataType>>(0)

      local $DataType[] result( len )
      forEach (i in first_index..last_index) result.add( data[i] )
      &count -= len
      ++modification_count
      data.copy_from( data, last_index+1, first_index, &count - first_index )
      data.clear( &count, &count+len-1 )
      return result

    generic method discard( Int32 first_index, Int32 last_index ):
      # Removes the elements in the specified range.  Does not return
      # the list of removed elements like remove() does.  If only
      # the 'first' parameter is given, elements from 'first' to the
      # end of the list are discarded.
      #
      # 'first' and 'last' are clipped to be a valid range. 
      if (first_index < 0) first_index = 0
      if (last_index >= &count) last_index = &count - 1

      local var len = (last_index - first_index) + 1

      if (len == 0) return

      if (last_index >= &count) throw InvalidOperandError("last_index","$"(last_index))

      &count -= len
      ++modification_count
      data.copy_from( data, last_index+1, first_index, &count - first_index )
      data.clear( &count, &count+len-1 )

    generic method discard_first:
      # Removes the first element in the list without returning it.
      &count--
      ++modification_count
      data.copy_from( data, 1, 0, &count )
      data.clear( &count, &count )

    generic method discard_last:
      # Removes the last element in the list without returning it.
      &count--
      ++modification_count
      data.clear( &count, &count )

    generic method discard_first( Int32 n ):
      # Removes 'n' elements from the front of the list.  Does not
      # return the list of removed elements like remove() does.
      &count -= n
      ++modification_count
      data.copy_from( data, n, 0, &count )
      data.clear( &count, &count+n-1 )

    generic method discard_last( Int32 n ):
      # Removes 'n' elements from the end of the list.  Does not
      # return the list of removed elements like remove() does.
      &count -= n
      ++modification_count
      data.clear( &count, &count+n-1 )

    generic method trim_to_count.$DataType[]:
      # Resizes the backing array to exactly fit the values currently
      # stored in this list.  Only recommended when memory usage is
      # a concern and you won't be adding additional elements in the 
      # near future.
      #
      # Returns:
      #   A reference to this list for call chaining.
      #
      # Invariant:
      #   capacity == count
      local Array<<$DataType>> new_data(count)
      new_data.copy_from( &data, 0, 0, count )
      data = new_data
      return this

    method create_duplicate.$DataType[]:
      # Creates a duplicate of this list when the "duplicate(list)"
      # command is given.  If the list element type is a reference 
      # type, the new list contains a copy of the same references
      # to the same objects - the objects themeselves are not 
      # duplicated.
      local ArrayList<<$DataType>> dup(count)
      dup.data.copy_from( data, 0, 0, count )
      dup.&count = count
      return dup

    generic requisite method clear: 
      # Removes all elements from this list.  The capacity
      # is unchanged.
      #
      # Invariant:
      #   new.count == 0
      #   new.capacity == old.capacity
      if (&count > 0) 
        data.clear(0,&count-1)
        &count = 0
        ++modification_count
      endIf
endClass


#=====================================================================
#  String and StringBuilder classes
#=====================================================================
requisite class String : Collection<<Char>>, Readable<<Char>>, ManagerCreates
  # A String stores text data.  Internally it is a simple wrapper
  # consisting of a Unicode Char array and a ''hash_code'' that
  # allows comparisons between unequal strings to be quickly resolved.
  #
  # Strings are immutable - operations return modified strings 
  # rather than changing the original.
  #
  #
  # Literal Strings<br>
  # There are several ways to write literal strings in Slag:
  #
  # {| class="slagdoc"
  # !width=256|"Within double quotes."
  # | The most common syntax. Literal double quotes can be part of the string by writing \".
  # |-
  # !//Within double slashes.//
  # |A good alternative when you will have a lot of double quotes in your string - you don't have to escape the double quotes and the string will be cleaner.
  # |-
  # ![string]<br/>Between string and endString preprocessor directives.<br/>[/endString]
  # |Has more overhead, but it makes it easy to write many lines of literal text.
  # Spaces and newlines are preserved exactly as they're typed.
  # |}
  #
  #
  # ==== Formatted Strings ====
  # Slag offers an easy way to create a string from a mix of literal string and
  # variable values.  If you follow a literal string with a parenthesized argument
  # list, the dollar signs ('$') in the literal string are replaced with their
  # corresponding arguments.
  #
  # For example, this code that creates a ''time'' string out of ''hours'' and
  # ''minutes'' values:
  #
  #   local String time = "" + hours + ":"
  #   if (minutes < 10) time += "0"
  #   time += minutes
  #
  # can be rewritten using the following formatted string:
  #
  #   local String time = "$:$(02)" (hours,minutes)
  #
  # Another example.  This:
  #
  #   println( "The position is [" + x + "," + y + "]." )
  #
  # can become:
  # 
  #   println( "The position is [$,$]." (x,y) )
  #
  # Underneath the compiler converts formatted strings and other string
  # concatenation to relatively quick operations that use a 
  # [[SlagDoc:StringBuilder|StringBuilder]] to compose the parts of a string 
  # without intermediate memory allocations.
  #
  # {| class="slagdoc"
  # |+ Format Marker Syntax
  # |-
  # !$
  # |Insert the ''argument.to_String()'' with no special formatting.
  # |-
  # !$$
  # |Not a format marker - instead displays a single '$'.
  # |-
  # !$()
  # |Same as just '$'. Necessary to have two consecutive markers ("$()$") since "$$" is an escape sequence.
  # |-
  # !$(5)
  # |Right-justifies the displayed value in a minimum of 5 spaces or digits total.
  # |-
  # !$(5.2)
  # |Right-justifies the displayed value with a minimum of 5 spaces before the decimal point and two spaces after the decimal point for 8 spaces total.
  # |-
  # !$(5.0)
  # |Prints only the integer portion of a real number.
  # |}
  #
  #
  # ==== Common String Operations ====
  # {| class="slagdoc"
  # !Operation !! Description
  # |-
  # |width=128|st1 == st2<br>
  # st1 != st2<br>
  # st1 > st2<br>
  # st1 >= st2<br>
  # st1 < st2<br>
  # st1 <= st2
  # | Compares the contents of two strings.
  # |-
  # | st1 is st2<br>
  # st1 isNot st2
  # | Determines whether or not two string variables reference the same object.
  # |-
  # | st.count || Returns the number of characters in ''st'', minimum zero.
  # |-
  # | st[i] || Returns the character at index ''i'', which must be between 0 and st.count-1.
  # |-
  # | forEach (ch in st)<br>
  # ...<br>
  # endForEach
  # |Loops "st.count" times with ch being a different character each time.
  # |-
  # |st1 += st2
  # |Assigns ''st1'' to be a new string that joins the contents of ''st1'' and ''st2''.
  # |}
  #
  #
  # ==== See Also ====
  # * [[SlagDoc:StringManager|StringManager]]
  # * [[SlagDoc:StringBuilder|StringBuilder]]
  # * [[SlagDoc:Scanner|Scanner]]
  # * [[SlagDoc:LineReader|LineReader]]
  CLASS_PROPERTIES
    consolidation_table() : HashSet<<String>>
      # Stores the unique strings created by [[SlagDoc:String#consolidate|String::consolidate()]].

  CLASS_METHODS
    method from_utf8( String utf8_encoded_string  ).String:
      # Decodes a UTF-8-encoded string and returns the result as a 
      # standard string.
      #
      # See also: [[SlagDoc:String#to_utf8|String::to_utf8()]]
      local StringBuilder buffer( utf8_encoded_string.count )
      local var src = utf8_encoded_string.create_reader

      while (src.has_another)

        local Int32 ch = src.read

        if ((ch & 0x80) != 0)
          local Int32 ch2 = src.read

          if ((ch & 0x20) == 0)
            # %110xxxxx 10xxxxxx
            ch  &= 0x1f
            ch2 &= 0x3f
            ch = ch.left_shifted(6) | ch2
          else
            # %1110xxxx 10xxxxxx 10xxxxxx
            local Int32 ch3 = src.read
            ch  &= 15
            ch2 &= 0x3f
            ch3 &= 0x3f
            ch = ch.left_shifted(12) | ch2.left_shifted(6) | ch3
          endIf
        endIf

        buffer.add( Char(ch) )

      endWhile

      return buffer.to_String

    method create_from( Array<<Char>> data, Int32 len=-1 ).String: native

    method create_from( Array<<Byte>> data, Int32 len=-1 ).String:
      if (len == -1) len = data.count
      local Char[] utf8( data.count )
      forEach (index of data) utf8.add( data[index] )
      return from_utf8( create_from(utf8) )

    method create_from( Char[] data ).String: return create_from(data.data,data.count)

    method create_from( Byte[] data ).String: return create_from(data.data,data.count)

    method create_from( Readable<<Char>> char_src ).String:
      local Char[] data()
      forEach (ch in char_src) data.add(ch)
      return create_from(data)

    method create_from( Readable<<Byte>> byte_src ).String:
      local Char[] data()
      forEach (ch in byte_src) data.add(ch)
      return create_from(data)

    method create_from( Byte n ).String:
      # Returns a String containing a string representation of ''n''.
      #
      # The compiler automatically converts an expression of the
      # form "byte_value + string" into 
      # "string.create_from(byte_value).op+(string)".
      return to_String(n)

    method create_from( Char ch ).String: native
      # Returns a String containing the single character ''ch''.
      #
      # The compiler automatically converts an expression of the
      # form "byte_value + string" into 
      # "string.create_from(byte_value).op+(string)".

    method create_from( Int64 n ).String:
      # Returns a String containing a string representation of ''n''.
      #
      # The compiler automatically converts an expression of the
      # form "byte_value + string" into 
      # "string.create_from(byte_value).op+(string)".
      # When arithmetic is performed between a non-reference on the
      # left side and a reference on the right-hand side, the RHS is
      # responsible for "promoting" the LHS to be its own type.
      return to_String(n)

    method create_from( Logical n ).String:
      # Returns a String containing a string representation of ''n''.
      #
      # The compiler automatically converts an expression of the
      # form "byte_value + string" into 
      # "string.create_from(byte_value).op+(string)".
      # When arithmetic is performed between a non-reference on the
      # left side and a reference on the right-hand side, the RHS is
      # responsible for "promoting" the LHS to be its own type.
      return to_String(n)

    method create_from( Real64 n ).String:
      # Returns a String containing a string representation of ''n''.
      #
      # The compiler automatically converts an expression of the
      # form "byte_value + string" into 
      # "string.create_from(byte_value).op+(string)".
      # When arithmetic is performed between a non-reference on the
      # left side and a reference on the right-hand side, the RHS is
      # responsible for "promoting" the LHS to be its own type.
      return to_String(n)

  METHODS
    private method init:
      throw Error( "Strings must be created using one of the String.create_from() methods." )

    method count.Int32: native
      # Returns the number of characters in this string.

    method hash_code.Int32: native
      # Returns the hash_code of this String.

    method get( Int32 index ).Char: native
      # Returns the character at the given zero-based index.  For example:
      #   local String st = "ABC"
      #   println( st[0] )  # prints: A


    method consolidate.String:
      # Returns an equivalent substitute string that is guaranteed
      # to be the same string object as any other equivalent string
      # previously returned by consolidate().
      #
      # For example, say that A and B are two separate strings such 
      # that "A == B" is true and "A is B" is false.
      #
      # After these calls:
      #
      #   A = A.consolidate
      #   B = B.consolidate
      #
      # then "A == B" and "A is B" are both true.
      #
      # When used with a large set of string data, this method
      # reduces memory usage and speeds up string comparisons.
      local var mapping = consolidation_table.find(this)
      if (mapping?) return mapping.key
      consolidation_table.add(this)
      return this

    method to_String.String:
      # Returns this String object unmodified.
      return this

    method modification_count.Int32:
      # Always returns 0 - Strings are immutable.
      return 0

    method create_reader.Reader<<Char>>:
      # Returns a reader that can be used to read() this data one 
      # element at a time.
      return StringReader( this, 0 )

    method from( Int32 starting_index ).Reader<<Char>>:
      # Returns a reader that can be used to read() this data one 
      # element at a time with the given 'starting_index'.
      return StringReader( this, starting_index )

    method from( Range<<Int32>> range ).Reader<<Char>>:
      # Returns a reader that can be used to read() this data one 
      # element at a time from the given starting index up to and
      # including the ending index.
      if (not range.is_contiguous_ascending)
        throw InvalidOperandError("range")
      endIf
      local Int32 first_i = range.first
      local Int32 n = (range.last - first_i) + 1
      return StringReader( this, first_i, n )

    method reverse_order.Reader<<Char>>:
      # Returns a reader that can be used to read() this data one 
      # element at a time from the last element (N-1) to the first (0).
      return StringReverseReader( this )

    method create_duplicate.String:
      # Returns this same String object since strings are immutable.
      return this

    method op==( Object other ).Logical:
      # Compares this string to another object.
      #
      # Returns false if ''other'' is not a string, or forwards the
      # call to String::op==(String) otherwise.
      if (other instanceOf String)
        return this.op==( other.(String) )
      else
        return false
      endIf

    method op==( String other ).Logical: native
      # Compares this string to another string.
      #
      # Returns:
      # * "false" if (this.hash_code != other.hash_code) or (this.count != other.count)
      # * "true" if all characters match between ''this'' and ''other''.

      #if (this is other) return true
      #if (&hash_code != other.&hash_code) return false
      #return op<>( other ) == eq

    method equals_ignore_case( String other ).Logical:
      # Returns true if this string is equal to another string,
      # ignoring the case of characters during comparison.
      #
      # For example, "ABcd".equals_ignore_case("AbCd") returns "true".
      local Int32 my_count = count
      local Int32 other_count = other.count
      if (count != other.count) return false
      local var other_reader = other.create_reader
      forEach (ch1 in this)
        local Char ch2 = other_reader.read
        if (ch1 >= 'a' and ch1 <= 'z') ch1 += ('A' - 'a')
        if (ch2 >= 'a' and ch2 <= 'z') ch2 += ('A' - 'a')
        if (ch1 != ch2) return false
      endForEach
      return true

    method op<>( Object other ).Int32
      # If ''other'' is a String the call is forwarded to op<>(String).
      # Otherwise an InvalidOperandError is thrown.
      if (other instanceOf String) return this.op<>( other.(String) )
      else throw InvalidOperandError("other","not a String")

    method op<>( String other ).Int32: native

    method matches_wildcard_pattern( String wildcard_pattern ).Logical:
      # Determines whether or not this string matches the given
      # Unix/Dos-style ''wildcard pattern''.  ''wildcard_pattern'' is a
      # regular text string that may contain the following special
      # characters:
      #
      # * * - matches zero or more characters of this string.
      # * ? - matches any one character of this string.
      #
      # Example:
      #
      #   local String st = "img_01.png"
      #   println( st.matches_wildcard_pattern("*.png") )  # true
      #   println( st.matches_wildcard_pattern("img_??.png") )  # true
      local Int32 c = count
      if (c == 0 and wildcard_pattern.count == 0) return true
      if (wildcard_pattern.count == 0) return false

      local String remaining_pattern = wildcard_pattern.substring( 1 )
      local Char ch = wildcard_pattern[0]
      which (ch)
        case '*':
          forEach (n in 0..c)
            if (substring(n).matches_wildcard_pattern(remaining_pattern)) return true
          endForEach

        case '?':
          if (c == 0) return false
          return substring(1).matches_wildcard_pattern( remaining_pattern )

        others:
          if (c == 0) return false
          if (ch == this[0])
            return substring(1).matches_wildcard_pattern( remaining_pattern )
          endIf
      endWhich
      return false

    method op+( String other ).String: native
      # Returns a new string consisting of ''this'' concatenated with 
      # ''other''.

      #{
      if (other is null) return this + "null"

      if (other.count == 0) return this
      if (count == 0) return other

      local var len = &data.count
      local Array<<Char>> joined( len + other.count )
      joined.copy_from( &data, 0, 0, len )
      joined.copy_from( other.&data, 0, len, other.&data.count )
      return String( joined )
      }#

    method op+( Char ch ).String: native
      # Returns a new string consisting of ''this'' concatenated with 
      # ''ch''.
      #{
      local var len = &data.count
      local Array<<Char>> joined( len + 1 )
      joined.copy_from( &data, 0, 0, len )
      joined[len] = ch
      return String( joined )
      }#

    method op+( Int64 n ).String:
      # Returns a new string consisting of ''this'' concatenated with 
      # a base 10 string representation of ''n''.
      return this + n.to_String

    method op+( Int32 n ).String:
      # Returns a new string consisting of ''this'' concatenated with 
      # a base 10 string representation of ''n''.
      return this + n.to_String

    method op+( Byte n ).String:
      # Returns a new string consisting of ''this'' concatenated with 
      # a base 10 string representation of ''n''.
      return this + Int32(n)

    method op+( Real64 n ).String:
      # Returns a new string consisting of ''this'' concatenated with 
      # a base 10 string representation of ''n''.
      return this + n.to_String

    method op+( Logical n ).String:
      # Returns a new string consisting of ''this'' concatenated with 
      # string representation of ''n''.
      return this + n.to_String

    method op+( Object obj ).String:
      # Adds the string representation of the given object to this
      # string and returns the joined string.
      return this + to_String(obj)

    method substring( Int32 first_index, Int32 last_index ).String: native
      # Returns the sequence of characters in the range 
      # [first_index,last_index], inclusive.  Note that this differs
      # from Java's substring() by having the second parameter be 
      # inclusive rather than exclusive.
      #
      # Requires:
      # * ''first_index'' >= 0
      # * ''last_index'' < ''count''
      # * ''first_index'' <= ''last_index''

    method substring( Int32 first_index ).String:
      # Returns the subsequence of characters from this[first_index]
      # up to the end of the string.
      #
      # Requires 0 <= ''first_index'' <= ''count''.
      return substring( first_index, count-1 )

    method reversed.String:
      # Returns an list containing the elements of this String in reverse order.
      local StringBuilder buffer( this )
      buffer.reverse
      return buffer.to_String

    method get( Range<<Int32>> range ).String:
      # Returns the substring of characters specified by the given
      # range of indices.
      # Note: st[range] is the same as st.get(range).
      #
      # Requires that all indices of the range be valid string 
      # indices 0..<''count''.
      #
      # Example:
      #
      #   local String st('A'..'F')   #st: ABCDEF
      #   println( st[0..4 step 2] )  # prints: ACE
      if (range.is_contiguous_ascending)
        return substring( range.first, range.last )
      else
        throw InvalidOperandError("range")
      endIf

    method get( Readable<<Int32>> range ).String:
      # Returns the substring of characters specified by the given
      # range of indices.
      # Note: st[range] is the same as st.get(range).
      local StringBuilder buffer()
      forEach (i in range) buffer.print(this[i])
      return buffer.to_String

    method index_of( String other, Int32 starting_index=0 ).Int32:
      # Finds the first occurrence of the ''other'' string within
      # ''this'' string, with an optional starting index (default: 0).
      #
      # Returns the index of the beginning of the match, or "-1" if
      # there's no match.
      #
      # Examples:
      #
      #   println( "abcdef".index_of("cd") )
      #     # prints: 2
      #   
      #   println( "abcdef".index_of("cd",2) )
      #     # prints: 2
      #   
      #   println( "abcdef".index_of("cd",3) )
      #     # prints: -1
      if (other.count == 0 or other.count > this.count) return -1
      local Char first_ch = other[0]
      forEach(index in starting_index..count-other.count)
        if (this[index] == first_ch)
          local var success = true
          forEach (i of other)
            if (this[index+i] != other[i]) success = false; escapeForEach
          endForEach
          if (success) return index
        endIf
      endForEach
      return -1

    method last_index_of( String other, Int32 starting_index=-1 ).Int32:
      # Returns the last (rightmost) occurrence of the ''other'' string
      # within this string.  An optional starting index may be passed
      # as the second parameter (default: count-1).
      #
      # Returns the leftmost index of the match or -1 if there's no 
      # match.
      #
      # Examples:
      #
      #   println( "abab".last_index_of("ab") )   # prints: 2
      #   println( "abab".last_index_of("ab",2) ) # prints: 2
      #   println( "abab".last_index_of("ab",1) ) # prints: 0
      #   println( "abab".last_index_of("zz") )   # prints: -1
      if (other.count == 0 or other.count > this.count) return -1

      if (starting_index == -1) starting_index = count
      else starting_index++

      local Char first_ch = other[0]
      forEach(index in (starting_index-other.count) .. 0 step -1)
        if (this[index] == first_ch)
          local var success = true
          forEach (i of other)
            if (this[index+i] != other[i]) success = false; escapeForEach
          endForEach
          if (success) return index
        endIf
      endForEach
      return -1

    method begins_with( String st ).Logical:
      # Returns "true" if this string begins with the given substring
      # or "false" otherwise.
      return index_of( st ) == 0

    method begins_with( Char ch ).Logical:
      # Returns "true" if this string begins with the given character
      # or "false" otherwise.
      return count? and this[0] == ch

    method starts_with( String st ).Logical:
      # DEPRECATED as of v0.21.  Use begins_with() instead.
      return index_of( st ) == 0

    method ends_with( String st ).Logical:
      # Returns "true" if this string ends with the given substring
      # or "false" otherwise.
      if (st.count > count) return false
      local Int32 start = count - st.count
      forEach (i of st)
        if (this[start+i] != st[i]) return false
      endForEach
      return true

    method ends_with( Char ch ).Logical:
      # Returns "true" if this string ends with the given character
      # or "false" otherwise.
      return count? and last == ch

    method contains( String other ).Logical:
      # Returns "true" if this string contains the given string
      # as a subsequence.
      return (index_of(other) >= 0)

    method replace( Char look_for, Char replace_with ).String:
      # Returns a modified string where all instances of
      # ''look_for'' are replaced with ''replace_with''.
      local StringBuilder buffer()
      forEach (ch in this)
        if (ch == look_for) buffer.print( replace_with )
        else                buffer.print( ch )
      endForEach
      return buffer.to_String

    method replace( Char look_for, String replace_with ).String:
      # Returns a modified string where all instances of
      # ''look_for'' are replaced with ''replace_with''.
      local StringBuilder buffer()
      forEach (ch in this)
        if (ch == look_for) buffer.print( replace_with )
        else                buffer.print( ch )
      endForEach
      return buffer.to_String

    method replace( String look_for, String replace_with ).String:
      # Returns a modified string where all instances of
      # ''look_for'' are replaced with ''replace_with''.
      local StringBuilder buffer()
      local var st = this
      local var i = st.index_of(look_for)
      if (i == -1) return st
      while (i >= 0)
        buffer.print( st.before(i) )
        buffer.print( replace_with )
        st = st.substring( i + look_for.count )
        i = st.index_of(look_for)
      endWhile
      buffer.print( st )
      return buffer.to_String

    method leftmost( Int32 num_chars ).String:
      # Returns the leftmost ''num_chars'' of this string as a 
      # substring.
      #
      # Equivalent to ''before(num_chars)''.
      #
      # Requires ''num_chars'' <= ''count''.
      #
      # Example:
      #
      #   println( "happy".leftmost(3) )
      #     # prints: hap
      return substring( 0, num_chars-1 )

    method rightmost( Int32 num_chars ).String:
      # Returns the rightmost ''num_chars'' of this string as a 
      # substring.
      #
      # Requires ''num_chars'' <= ''count''.
      #
      # Example:
      #
      #   println( "happy".rightmost(2) )
      #     # prints: py
      local var len = count  #slight speed optimization
      return substring( len - num_chars, len-1 )

    method excluding_leftmost( Int32 num_chars ).String:
      # Returns the substring of all characters after the leftmost 
      # ''num_chars'' of this string.  Equivalent to ''substring(num_chars)''.
      #
      # Requires ''num_chars'' <= ''count''.
      #
      # Example:
      #
      #   println( "happy".excluding_leftmost(3) )
      #     # prints: py
      return substring(num_chars)

    method excluding_rightmost( Int32 num_chars ).String:
      # Returns the substring of all characters before the rightmost 
      # 'num_chars' of this string.
      #
      # Requires ''num_chars'' <= ''count''.
      #
      # Example:
      #   println( "happy".excluding_rightmost(2) )
      #     # prints: hap
      return leftmost( count - num_chars )

    method excluding_substring( Int32 first, Int32 last ).String:
      # Returns all the characters before 'first' and after 
      # 'last' - the complement of substring(first,last).
      # 
      # Example:
      #
      #   println( "happy".excluding_substring(2,3) )
      #     # prints: hay
      local StringBuilder buffer()
      buffer.print( leftmost(first) )
      buffer.print( rightmost( count-(last+1) ) )
      return buffer.to_String

    method before( Int32 index ).String:
      # Returns the substring of this string that occur before
      # the given index.
      #
      # Equivalent to ''leftmost(index)''.
      return substring(0,index-1)

    method after( Int32 index ).String:
      # Returns the substring of this string that occur after
      # the given index.
      #
      # Equivalent to ''substring(index+1)''.
      return substring(index+1)

    method before_first( Char ch ).String:
      # Returns the substring of this string that occurs before
      # the first occurrence of the given character, or returns 
      # the entire string if ''ch'' does not occur in this string.
      local var pos = index_of(ch)
      if (pos == -1) return this
      return leftmost(pos)

    method before_last( Char ch ).String:
      # Returns the substring of this string that occurs before
      # the last occurrence of the given character, or returns 
      # the entire string if ''ch'' does not occur in this string.
      local var pos = last_index_of(ch)
      if (pos == -1) return this
      return leftmost(pos)

    method after_last( Char ch ).String:
      # Returns the substring of this string that occurs after
      # the last occurrence of the given character, or returns 
      # the entire string if ''ch'' does not occur in this string.
      local var pos = last_index_of(ch)
      if (pos == -1) return this
      return substring(pos+1)

    method after_first( Char ch ).String:
      # Returns the substring of this string that occurs after
      # the first occurrence of the given character, or returns 
      # the entire string if ''ch'' does not occur in this string.
      local var pos = index_of(ch)
      if (pos == -1) return this
      return substring(pos+1)

    method from_first( Char ch ).String:
      # Returns the substring of this string that occurs starting
      # at the first occurrence of the given character, or returns 
      # an empty string if ''ch'' does not occur in this string.
      local var pos = index_of(ch)
      if (pos == -1) return ""
      return substring(pos)

    method before_first( String st ).String:
      # Returns the substring of this string that occurs before
      # the first occurrence of the given string, or returns 
      # the entire string if ''st'' does not occur in this string.
      local var pos = index_of(st)
      if (pos == -1) return this
      return leftmost(pos)

    method before_last( String st ).String:
      # Returns the substring of this string that occurs before
      # the first occurrence of the given string, or returns 
      # the entire string if ''st'' does not occur in this string.
      local var pos = last_index_of(st)
      if (pos == -1) return this
      return leftmost(pos)

    method after_last( String st ).String:
      # Returns the substring of this string that occurs after
      # the last occurrence of the given string, or returns 
      # the entire string if ''st'' does not occur in this string.
      local var pos = last_index_of(st)
      if (pos == -1) return this
      return substring(pos+st.count)

    method after_first( String st ).String:
      # Returns the substring of this string that occurs after
      # the last occurrence of the given string, or returns 
      # the entire string if ''st'' does not occur in this string.
      local var pos = index_of(st)
      if (pos == -1) return this
      return substring(pos+st.count)

    method from_first( String st ).String:
      # Returns the substring of this string that occurs starting
      # at the first occurrence of the given string, or returns 
      # an empty string if ''st'' does not occur in this string.
      local var pos = index_of(st)
      if (pos == -1) return ""
      return substring(pos)

    method right_justified( Int32 min_chars, Char fill_char=' ' ).String:
      # Returns a new string containing this string right-justified
      # in a field width of ''min_chars'', with a space as the default 
      # ''fill_char''.
      #
      # If this string is already ''min_chars'' in length, no modifications
      # are made.
      #
      # Example:
      #
      #   println( "slag".right_justified(7,'0') )
      #     # prints: 000slag
      if (count >= min_chars) return this
      local StringBuilder builder( min_chars )
      forEach ( 1..(min_chars-count) ) builder.print( fill_char )
      builder.print( this )
      return builder.to_String

    method left_justified( Int32 min_chars, Char fill_char=' ' ).String:
      # Returns a new string containing this string left-justified
      # in a field width of ''min_chars'', with a space as the default 
      # ''fill_char''.
      #
      # If this string is already ''min_chars'' in length, no modifications
      # are made.
      #
      # Example:
      #
      #   println( "slag".left_justified(7,'!') )
      #     # prints: slag!!!
      if (count >= min_chars) return this
      local StringBuilder builder( min_chars )
      builder.print( this )
      forEach ( 1..(min_chars-builder.count) ) builder.print( fill_char )
      return builder.to_String

    method centered( Int32 min_chars, Char fill_char=' ' ).String:
      # Returns a new string containing this string centered
      # in a field width of ''min_chars'', with a space as the default 
      # ''fill_char''.
      #
      # If this string is already ''min_chars'' in length, no modifications
      # are made.
      #
      # Example:
      #
      #   println( "slag".centered(7,'-') )
      #     # prints: -slag--
      if (min_chars < count) min_chars = count
      local StringBuilder builder( min_chars )
      local var lhs = (min_chars - count) / 2
      local var rhs = (min_chars - count) - lhs
      forEach (1..lhs) builder.print( fill_char )
      builder.print( this )
      forEach (1..rhs) builder.print( fill_char )
      return builder.to_String

    method to_Int32( Int32 base=10 ).Int32:
      # Parses an Int32 out of this string and returns it.
      #
      # Example:
      #
      #   local Int32 n = "456".to_Int32
      #   println( n )  # prints: 456
      return NumberConversions.parse_Int32(this,base)

    method to_Int64( Int32 base=10 ).Int64:
      # Parses an Int64 out of this string and returns it.
      #
      # Example:
      #
      #   local Int64 n = "456".to_Int64
      #   println( n )  # prints: 456
      return NumberConversions.parse_Int64(this,base)

    method to_Real64.Real64:
      # Parses a Real64 out of this string and returns it.
      #
      # Example:
      #
      #   local Real64 n = "3.14".to_Real64
      #   println( n )  # prints: 3.1400
      return NumberConversions.parse_Real64(this)

    method to_Real32.Real32:
      # Parses a Real32 out of this string and returns it.
      return Real32(to_Real64)

    method to_Logical.Logical:
      # Parses a Logical out of this string and returns it.
      #
      # true values:
      # * "true"
      # * "yes"
      # * non-zero numbers
      #
      # false values:
      # * Anything else
      if (this == "true" or this == "yes") return true
      try
        if (to_Int64 != 0) return true
      catch (Error err)
      endTry
      return false


    method to_uppercase.String:
      # Returns an uppercase version of this string.  Lowercase "a-z"
      # letters become capital "A-Z" while other letters and symbols 
      # remain unmodified.
      #
      # Example:
      #
      #   println( "Hello World!".to_uppercase )
      #     # prints: HELLO WORLD!
      local StringBuilder builder( count )
      forEach (ch in this)
        if (ch >= 'a' and ch <= 'z') ch += ('A' - 'a')
        builder.print( ch )
      endForEach
      return builder.to_String

    method to_lowercase.String:
      # Returns a lowercase version of this string.  Uppercase "A-Z"
      # letters become lower "a-z" while other letters and symbols 
      # remain unmodified.
      #
      # Example:
      #
      #   println( "Hello World!".to_lowercase )
      #     # prints: hello world!
      local StringBuilder builder( count )
      forEach (ch in this)
        if (ch >= 'A' and ch <= 'Z') ch += ('a' - 'A')
        builder.print( ch )
      endForEach
      return builder.to_String

    method capitalized.String:
      # Returns a capitalized version of this string - if the first
      # letter is lowercase "a-z" it is turned into its uppercase
      # equivalent.  There are no other changes.
      if (count == 0) return this
      local Char ch = this[0]
      if (ch < 'a' or ch > 'z') return this
      return Char(ch + ('A'-'a')) + substring(1)

    method split( Char divider_char=' ' ).String[]:
      # Splits this string into an array of string objects around (and
      # not including) the specified divider_char (default: space).  
      # You may wish to tidy() the string first.
      #
      # Returns a list of String objects.
      #
      # Example:
      #
      #   println( "a b  c ".split )
      #     # prints:
      #     #   a
      #     #   b
      #     #
      #     #   c
      local String[] tokens()
      local StringBuilder buffer()
      forEach (ch in this)
        if (ch == divider_char)
          tokens.add( buffer.to_String )
          buffer.clear
        else
          buffer.print( ch )
        endIf
      endForEach

      tokens.add( buffer.to_String )
      return tokens

    method split( String divider_string ).String[]:
      # Splits this string into an array of string objects around (and
      # not including) each character.  You may wish to tidy() the 
      # string first.
      #
      # Returns a list of String objects.
      #
      # Example:
      #
      #   println( "a::b::::c ".split("::") )
      #     # prints:
      #     #   a
      #     #   b
      #     #
      #     #   c
      local String[] tokens()
      local var cur = 0
      local var next_split = index_of(divider_string)
      while (next_split != -1)
        tokens.add( substring(cur,next_split-1) )
        cur = next_split + divider_string.count
        next_split = index_of( divider_string, cur )
      endWhile

      tokens.add( substring(cur) )
      return tokens

    method trim.String:
      # Removes any spaces and non-printable characters from both
      # ends of this string.  See tidy() for an alternative that
      # removes extra spaces internally as well.
      #
      # Returns the modified string.
      #
      # Example:
      #   println( "($)" ("  a   b  ".trim) )
      #     # prints: (a   b)
      if (count == 0) return this

      local Int32 len = count
      local Int32 i1 = 0
      local Int32 i2 = len - 1
      while (i1 < len)
        local Char ch = this[i1]
        if (ch > ' ' and ch != 127) escapeWhile
        i1++
      endWhile
      while (i2 >= 0)
        local Char ch = this[i2]
        if (ch > ' ' and ch != 127) escapeWhile
        i2--
      endWhile
      if (i1 > i2) return ""
      return substring(i1,i2)

    method tidy.String:
      # Converts tabs and other non-printable characters to spaces, 
      # removes all spaces from the ends, and converts groups of 
      # spaces into single spaces.
      #
      # Returns the modified string.
      #
      # Example:
      #
      #   println( "($)" ("  a   b  ".tidy) )
      #     # prints: (a b)
      if (count == 0) return this

      local Int32 len = count
      local Int32 i1 = 0
      local Int32 i2 = len - 1
      while (i1 < len)
        local Char ch = this[i1]
        if (ch > ' ' and ch != 127) escapeWhile
        i1++
      endWhile
      while (i2 >= 0)
        local Char ch = this[i2]
        if (ch > ' ' and ch != 127) escapeWhile
        i2--
      endWhile
      if (i1 > i2) return ""

      local StringBuilder buffer()
      local Logical just_read_space = true
      forEach (i in i1..i2)
        local Char ch = this[i]
        if (ch < ' ' or ch == 127) ch = ' '

        if (ch == ' ')
          if (not just_read_space) buffer.print(ch); just_read_space = true
        else
          just_read_space = false
          buffer.print( ch )
        endIf
      endForEach

      return buffer.to_String

    method word_wrap( Int32 width ).String[]:
      # Returns a word-wrapped version of this string as a list of lines.
      # Existing newlines characters will cause a new line to begin
      # immediately.  Spaces immediately following existing newline 
      # characters are preserved.
      local String[] lines()
      local Int32 i1=0, i2=0
      local Int32 len = count

      while (i2 < len)

        # find last space or first \n
        while ((i2-i1) < width and i2 < len and this[i2] != '\n') i2++

        if ((i2-i1) == width)
          if (i2 >= len)
            i2 = len
          else
            while (this[i2]!=' ' and this[i2]!='\n' and i2>i1) i2--
            if (i2 == i1) i2 = i1 + width
          endIf
        endIf

        lines.add( substring(i1,i2-1) )

        if (i2 == len)
          return lines
        else
          which (this[i2])
            case ' ':
              while (i2<len and this[i2]==' ') i2++
              if (i2<len and this[i2]=='\n') i2++

            case '\n':
              i2++
          endWhich
          i1 = i2
        endIf
      endWhile

      return lines

    method to_utf8.String:
      # Returns a copy of this string encoded in UTF-8 format where only
      # the lower 8 bits of each character are used.  Any character
      # with the unicode range 0..127 is unchanged; characters originally
      # having a higher unicode value are encoded into a sequence of 2 or 3 
      # consecutive characters.
      #
      # See also:
      # * [[SlagDoc:StringManager#from_utf8_String|StringManager.from_utf8_String]]
      local StringBuilder result(count)

      forEach (ch in this)
        if (ch < 0x80)
          # %0xxxxxxx
          result.print( ch )

        elseIf (ch < 0x800)
          # %110xxxxx 10xxxxxx
          result.print( Char(((ch.right_shifted(6)) & 0x1f) | 0xc0) )
          result.print( Char((ch & 0x3f) | 0x80) )

        else
          # %1110xxxx 10xxxxxx 10xxxxxx
          result.print( Char(((ch.right_shifted(12)) & 15) | 0xe0) )
          result.print( Char(((ch.right_shifted(6)) & 0x3f) | 0x80) )
          result.print( Char((ch & 0x3f) | 0x80) )

        endIf

      endForEach

      return result.to_String

    method to_List.Char[]:
      # Returns this string's characters as an arraylist.
      return Char[]( to_Array, false )

    method to_Array.Array<<Char>>: native
      # Returns this string's characters as an array.

    method pluralize( Int32 quantity ).String:
      # Returns a pluralized form of this string.
      #
      # This string may be of the form "singlar" or "singlar/plural",
      # where both singular and plural parts may contain a "#"
      # to indicate where the given ''quantity'' should be inserted.
      #
      # If the string only contains the "singular" part, first a
      # substring of the form "(s)" or "(es)" (etc.) is looked for.  
      # If that exists, it is included in the result if the string
      # is plural and omitted if the string is singular.
      #
      # If there is no "(s)" (etc.) then either "s" or "es" is 
      # inserted after the last letter - "es" is used only when the 
      # last letter is an "s" already.
      #
      # Examples:
      #
      #   "cat".pluralize(1)   # returns: cat
      #   "cat".pluralize(2)   # returns: cats
      #   "My # glass.".pluralize(1)  # returns: My 1 glass.
      #   "My # glass.".pluralize(2)  # returns: My 2 glasses.
      #   "a thief./# thieves".pluralize(1)   # returns: a thief.
      #   "a thief./# thieves".pluralize(40)  # returns: 40 thieves.
      #   "# match(es) found".pluralize(1)    # returns: 1 match found
      #   "# match(es) found".pluralize(0)    # returns: 0 matches found
      local var st = this.replace( "#", ""+quantity )

      if (st.contains('/'))
        if (quantity == 1) return st.before_first( '/' )
        else               return st.after_last( '/' )

      else
        local var alt1 = st.index_of('(')
        local var alt2 = st.index_of(')',alt1+1)

        if (quantity == 1) 
          if (alt1 >= 0) return st.before(alt1) + st.after(alt2)
          else return st
        endIf

        # plural
        if (alt1 >= 0)
          return "$()$()$()" (st.before(alt1),st.substring(alt1+1,alt2-1),st.after(alt2))
        else
          local var index = 0
          forEach (i in st.reverse_indices)
            if (st[i].is_letter) index = i; escapeForEach
          endForEach

          if (st[index] == 's') return "$es$" (st.before(index+1),st.after(index))
          else                  return "$s$" (st.before(index+1),st.after(index))
        endIf

      endIf

    method shuffled.String:
      # Returns a modified string containing the original characters of this 
      # string in a random order.
      local StringBuilder buffer(count)
      local StringBuilder src(this)
      while (src.count?) buffer.add( src.remove_random )
      return buffer.to_String

endClass



requisite class StringBuilder : TextWriter, ListOperations<<Char,StringBuilder>>
  # Class for composing Strings.  Using a StringBuilder is more 
  # efficient than concatenating Strings ("a" + "b") when three
  # or more concatenations are involved.
  #
  # Example:
  #   local Int32 x = 5
  #   local StringBuilder buffer()
  #   buffer.print( "The value of x is " )
  #   buffer.print( x )
  #   buffer.print( "!" )
  #   println( buffer.to_String )  # prints: The value of x is 5!
  #
  # Note: StringBuilder inherites all the variations of print()
  # and println() from base class TextWriter.
  PROPERTIES
    data : Char[]
      # The internal character buffer.

  METHODS
    method init( Int32 capacity=80 )
      # Initializes this StringBuffer to be able to store 'capacity'
      # (default 80) characters before having to automatically resize.
      data = ArrayList<<Char>>(capacity)

    method init( Char ch )
      # Initializes this StringBuilder to the default size and
      # store the given character ''ch''.
      init()
      print(ch)

    method init( String st )
      # Initializes this StringBuilder to contain the string ''st''
      # to start with.
      init()
      print( st )

    method create_reader.ArrayReader<<Char>>:
      # Returns a reader that can be used to read() this data one 
      # element at a time.
      return data.create_reader

    method capacity.Int32
      # Returns how many total characters this StringBuilder can
      # store before it will resize its internal buffer.
      return data.capacity

    method from( Int32 starting_index ).ArrayReader<<Char>>:
      # Returns a reader that can be used to read() this data one 
      # element at a time with the given 'starting_index'.
      return data.from(starting_index)

    method from( Range<<Int32>> range ).ArrayReader<<Char>>:
      # Returns a reader that can be used to read() this data one 
      # element at a time from the given starting index up to and
      # including the ending index.
      return data.from(range)

    method reverse_order.ArrayReader<<Char>>:
      # Returns a reader that can be used to read() this data one 
      # element at a time from the last element (N-1) to the first (0).
      return data.reverse_order

    method add( String st ).StringBuilder:
      # Primarily used for internal call chaining - using print() or 
      # println() is a more efficient way to write strings.
      #
      # Example:
      #   local StringBuilder buffer()
      #   buffer.add(alpha).add(beta)
      print( st )
      return this

    method print( String st ):
      # Prints the given String to this StringBuilder.
      # A more efficient override of the base class method.
      if (st is null) st = "null"
      data.ensure_capacity( data.count + st.count )
      native_copy( st, data.data, data.count )
      data.&count += st.count

    private method native_copy( String src_string, 
        Array<<Char>> dest_array, Int32 dest_offset ): native
      # Internal use.

    method write( Char ch ):
      # Fundamental write operation that all the TextWriter methods
      # depend on.
      data.add( ch )

    method clear:
      # Clears all the characters from this StringBuilder.
      data.clear

    method count.Int32:
      # Returns the number of characters printed to this StringBuilder
      # so far.
      return data.count

    method modification_count.Int32:
      # Returns the number of times this list has had an element added to
      # or removed from it.
      return data.modification_count

    method get( Int32 i ).Char:
      # Returns the character at zero-based index 'i'.
      return data[i]

    method set( Int32 i, Char value ):
      # Sets the character at zero-based index 'i'.
      data[i] = value

    method insert( Char value, Int32 before_index ).StringBuilder:
      # Inserts the given character before the given index.
      data.insert( value, before_index )
      return this

    method remove( Int32 index ).Char:
      # Removes the character at 'index' and shifts characters
      # down to close the gap.
      return data.remove( index )

    method discard( Int32 first_index, Int32 last_index=-1 ):
      # Discards all characters from the first index through the last
      # index, or through the end if no last index is given.
      data.discard( first_index, last_index )

    method to_String.String: 
      # Converts the data in this StringBuilder to a String.
      if (count == 0) return ""
      local Array<<Char>> str_data(count)
      str_data.copy_from( data.data, 0, 0, count )
      return String.create_from(str_data)

endClass

#=====================================================================
#  Base Readable/Reader and Writable/Writer classes
#=====================================================================
requisite aspect ReadableType;
  # Indicates something is Readable for some datatype.  Used by the
  # compiler to distinguish between readables and readers when
  # processing forEach loops.

requisite aspect ReaderType;
  # Indicates something is a Reader of some datatype.  Used by the
  # compiler to distinguish between readables and readers when
  # processing forEach loops.


underlying aspect Readable<<$DataType>> : ReadableType
  # Base aspect for any object that can create a reader of type
  # '$DataType'.  To make a Readable class, incorporate this aspect
  # and implement create_reader().
  #
  # forEach loops automatically work with readable and reader types.
  METHODS
    method create_reader.Reader<<$DataType>>: abstract
      # Creates and returns a reader capable of reading the data from
      # this object.

    method to_List.$DataType[]:
      # Converts this Readable data into a list.  Creates a reader
      # and fowards the call to it.
      return create_reader.to_List

endAspect

augment Readable<<Char>>
  METHODS
    method to_bytes.Byte[]:
      # Turns this Readable Char data into a Byte[] list.
      # Available for Readable<<Char>> types only.
      return create_reader.to_bytes
endAugment


underlying aspect Reader<<$DataType>> : ReaderType #, ListAdaptable<<$DataType>>
  # Base aspect for all readers.  A reader is something that can
  # return a series of values of a given datatype.  To make a class a Reader,
  # incorporate this aspect and define has_another(), peek(), and read().
  #
  # forEach loops automatically work with readable and reader types.
  #
  # See also: Readable<<$DataType>>, StandardReader<<$DataType>>.

  METHODS
    method has_another.Logical: abstract
      # Returns "true" if this reader has another value that can
      # be previewed with peek() or read with read().
      #
      # Some "generator" readers, such as random number generators,
      # *always* have another value.

    method peek.$DataType:       abstract
      # Returns the next value that will be returned from read().
      # If there is no next value then a NoNextValueError is thrown.

    method read.$DataType:       abstract
      # Returns the next value from this reader.  If (not has_another)
      # then a NoNextValueError is thrown.

    method is_exhausted.Logical:
      # Returns "true" if this reader does not have another value
      # or "false" if it does.
      return (not has_another)

    method available.Int32: 
      # Returns the minimum number of additional values that can be
      # immediately read from this reader.  
      #
      # If the reader is exhausted or if it must block to peek or 
      # read next then the result will be 0.  It is important to note 
      # that '0' does not necessarily mean the reader is exhausted.
      #
      # Many readers will report that they have 1 available even if
      # there are thousands of values waiting to be read.  The
      # 'available' property should be used as an aide for buffer
      # sizes and the like but should not be taken as an absolute
      # size.
      if (has_another) return 1
      else          return 0

    method remaining.Int32:
      # This optional property returns how many values remain to be
      # read before the reader is exhausted.  Not all readers 
      # can implement this property; those that don't will throw
      # an UnsupportedMethodError when it's accessed.
      throw UnsupportedMethodError()

    method position.Int32:
      # This optional property-read returns the zero-based read 
      # position of this reader.  When a reader is first created 
      # position() returns 0.  After a single read() it returns 1, 
      # and so on.
      #
      # Readers that don't implement this property will throw an
      # UnsupportedMethodError when it's accessed.
      throw UnsupportedMethodError()

    method position( Int32 new_position ):
      # This optional property-write sets the zero-based read position
      # of this reader.  When a reader is first created position()
      # returns 0.  After a single read() it returns 1, and so on.
      # Readers that don't implement this property will throw an
      # UnsupportedMethodError when it's accessed.
      throw UnsupportedMethodError()

    method rewind: 
      # This optional method resets this reader so that the next
      # read() will return the first value of the series.
      # Readers that don't implement this property will throw an
      # UnsupportedMethodError when it's accessed.
      position = 0

    method skip( Int32 skip_count=1 ):
      # Discards exactly the next 'skip_count' number of values 
      # rather than reading them.  If there are not enough values 
      # remaining then a NoNextValueError will be thrown from read().
      #
      # This program fragment:
      #   local var a = reader.read
      #   reader.read
      #   reader.read
      #   local var b = reader.read
      #
      # is equivalent to this:
      #   local var a = reader.read
      #   reader.skip(2)
      #   local var b = reader.read
      forEach (1..skip_count) read

    method consume( $DataType look_for ).Logical:
      # Attempts to match and discard the next value from this 
      # reader, returning true, or else leaves the next value still 
      # pending and returns false.
      #
      # Returns:
      #   "true" if old.peek == look_for
      #   "false" if old.peek != look_for
      #
      # Invariant:
      #   if (old.peek == look_for) old.skip
      if (not has_another) return false
      if (peek == look_for) read; return true
      return false

    method to_List.$DataType[]:
      # Creates and returns a list of all the remaining values of
      # this reader.
      local $DataType[] result_list(available)
      while (has_another) result_list.add( read )
      return result_list

  METHODS
    method read_list( Int32 size ).$DataType[]:
      # Reads the next 'size' number of values and returns them in a
      # list.  Requires that there are at least 'size' number of 
      # values remaining to be read.
      local $DataType[] result_list( size )
      forEach (1..size) result_list.add( read )
      return result_list

    method close:
      # Closes this reader as a source of input.  Used for file
      # readers, but for most others this command does nothing.

    method to_String.String:
      # Returns a string representation of this reader's values.
      return to_List.to_String
endAspect


augment Reader<<Char>>
  METHODS
    method to_bytes.Byte[]:
      # Turns the values of this Reader<<Char>> into a Byte[] list.  
      # Available for Reader<<Char>> types only.
      local Byte[] list(available)
      while (has_another) list.add( read )
      return list

    method read_line.String:
      # Reads and returns the next line of characters up to the next
      # LF or CRLF.  The CRLF characters are not part of
      # the return value and are discarded.
      #
      # Only available for Reader<<Char>>.
      local StringBuilder result()
      forEach (ch in this)
        if (ch == 13) nextIteration
        if (ch == 10) escapeForEach
        result.print( ch )
      endForEach
      return result.to_String

endAugment

aspect TextReader : Reader<<Char>>
  # A convenience aspect for incorporating Reader<<Char>>.
  #
  # Example:
  #   class CustomTextReader : TextReader
  #     ...
  #   endClass
endAspect

underlying aspect StandardReader<<$DataType>> : Reader<<$DataType>>
  # Framework for a reader that has a peekable "next" element that
  # is set with prep_next.  To use, incorporate this aspect and
  # define the prep_next method.

  PROPERTIES
    next     : $DataType
      # Set in prep_next().  If has_next is null, the value of
      # 'next' is undefined.

    has_next : Logical
      # Set to the value returned from prep_next().

  METHODS
    method has_another.Logical: 
      # Returns "true" if this reader has another value that can
      # be previewed with peek() or read with read().
      return has_next

    method peek.$DataType:
      # Returns the next value that will be returned from read().
      # If there is no next value then a NoNextValueError is thrown.
      if (not has_next) throw NoNextValueError()
      return next

    method read.$DataType:
      # Returns the next value from this reader and prepares the
      # value that will come after.
      if (not has_another) throw NoNextValueError()
      local var result = next
      has_next = prep_next
      return result

    method prep_next.Logical: abstract
      # Sets up the next value to be returned.  This will be the
      # value returned from peek() and read by read().  Returns
      # true on success, false if there's nothing more to read.
endAspect

underlying aspect Writable<<$DataType>>
  # A type that's writable is capable of creating a writer
  # that knows how to write data to it.
  METHODS
    method create_writer.Writer<<$DataType>>: abstract
      # Returns a writer capable of writing data to this object.
endAspect

underlying aspect Writer<<$DataType>>
  # The base aspect for all writers.
  METHODS
    method write( $DataType value ):   abstract
      # Outputs 'value' in an implementation-specific way.
      #
      # Requires:
      #   holds_another == true

    method write( Reader<<$DataType>> src ):
      # Writes each of the values in 'src' to this writer.
      forEach (value in src) write(value)

    method capacity.Int32:
      # Returns the minimum number of additional values that can 
      # written with this writer, or (-1) for "unlimited".
      return -1

    method holds_another.Logical:
      # Returns true if at least one more value can be written with
      # write().
      return (capacity != 0)

    method position.Int32:
      # This optional property-read returns the zero-based write 
      # position.  This will be "0" before anything is written, "1" 
      # after a single write(), and so on.
      #
      # Not all writers implement this property; those that don't
      # will throw an UnsupportedMethodError when it's accessed.
      throw UnsupportedMethodError()

    method position( Int32 new_pos ):
      # This optional property-write sets the zero-based write 
      # position.  It is up to the implementation to define how 
      # repositioning works with gaps and what happens to data at a 
      # later spot after a reposition to an earlier spot.
      #
      # Not all writers implement this property; those that don't
      # will throw an UnsupportedMethodError when it's accessed.
      throw UnsupportedMethodError()

    method skip( Int32 skip_count ):
      # This optional method repositions the writer to be 
      # 'skip_count' values further along.
      #
      # If a writer does not implement the 'position' property then
      # an UnsupportedMethodError will be generated when skip()
      # is called.
      position = position + skip_count

    method flush:
      # Orders the writer to write out any buffered data in 
      # preparations for closing the writer.
      #
      # Invariant: close() should always call flush() first.

    method close:
      # Closes the writer; no further information may be written to
      # this writer.  Should always be called after data is finished
      # being written.
      #
      # Implementations should call flush() as the first step of 
      # close().
      #
      # Multiple calls to a writer's close() are permitted although
      # only the first call actually causes an action.
      flush

    method clean_up: 
      # Closes the writer.  Base aspect Writer does not incorporate 
      # the RequiresCleanup interface, but types for writers that do
      # this method will be called when there are no more references
      # to the object.
      close
      insertUnderlying
endAspect


class TextWriter : Writer<<Char>>
  # Defines a Writer<<Char>> that can print a variety of common Slag
  # types in text form.
  #
  # In Slag I/O terminology, "writing" data means to write successive
  # units of that data type to the output, while "printing" means 
  # to translate into text form.
  METHODS 
    method write( Char ch ):
      # Override this

    method print( Char ch ):
      # Prints the given Char.  The symbol corresponding
      # to the Unicode value of 'n' will be displayed.
      write(ch)

    method print( String st ):
      # Prints the given String.
      forEach (ch in st) 
        write(ch)
      endForEach

    method print( Object obj ): 
      # Prints the to_String representation of the given object, or
      # else the world "null" if the 'obj' reference is null.
      if (obj is null) print( "null" )
      else print( obj.to_String )

    method print( Int64   n ):
      # Prints the given Int64 in text form.
      print( to_String(n) )

    method print( Byte   n ):
      # Prints the given Byte in text form.
      print( to_String(n) )

    method print( Real64  n ):
      # Prints the given Real64 in text form.
      print( to_String(n) )

    method print( Real32  n ):
      # Prints the given Real32 in text form.
      print( to_String(n) )

    method print( Logical n ):
      # Prints the given Logical in text form as either "true" or "false".
      print( to_String(n) )

    method println( String st ):
      # Prints the given String value and advances the cursor to the
      # next line.
      print( st );  println()

    method println( Object obj ):
      # Prints the given object's to_String value and advances 
      # the cursor to the next line.
      print( obj ); println()

    method println( Int64   n ):
      # Prints the given Int64 value and advances the cursor to the
      # next line.
      print( n ); println()

    method println( Byte   n ):
      # Prints the given Byte value and advances the cursor to the
      # next line.
      print( n ); println()

    method println( Char    n ):
      # Prints the given Char value and advances the cursor to the
      # next line.
      print( n ); println()

    method println( Real64  n ):
      # Prints the given Real64 value and advances the cursor to the
      # next line.
      print( n ); println()

    method println( Logical n ):
      # Prints the given Logical value and advances the cursor to the
      # next line.
      print( n ); println()

    method println:
      # Advances the cursor to the next line.
      print( '\n' )

      #method print( Readable<<Char>> readable ):
      # Prints out every character in the Readable data.
      #print( readable.create_reader )

      #method println( Readable<<Char>> readable ):
      # Prints out every character in the Readable data and advances
      # the cursor to the next line.
      #println( readable.create_reader )

    method print( Reader<<Char>> reader ):
      # Prints out every character that can be obtained from the 
      # reader.
      forEach (ch in reader) print(ch)

    method println( Reader<<Char>> reader ):
      # Prints out every character that can be obtained from the 
      # reader and advances the cursor to the next line.
      print( reader )
      println

endClass


#=====================================================================
#  Readable Range classes
#=====================================================================
aspect RangeType
  # Common base type for all ranges.  Used by the compiler to perform
  # optimzations - for example, 'forEach(1..10)' is converted into a
  # simple 'while (i <= 10)' loop rather than generating a full-fledged
  # Reader object.
endAspect

class Range<<$DataType>> : Readable<<$DataType>>, RangeType
  # Models a range of numbers with a first value, a last value, and a 
  # step size.  This base range class spans the ascending or 
  # descending range [first,last] in steps of 'step_size'.
  #
  # Range objects are normally created by the compiler from 
  # "low..high" or "low upTo high" expressions.
  PROPERTIES
    first, last, step_size : $DataType

  METHODS
    method init( first ):
      # Creates a Range that will read a single given number.
      last = first
      step_size = $DataType(1)

    method init( first, last ):
      # There are two init() methods instead of supplying a
      # default parameter for the step_size so the compiler
      # can recognize a Range with the default step size and
      # perform a to-while optimization.
      step_size = $DataType(1)

    method init( first, last, step_size ):

    method create_reader.Reader<<$DataType>>:
      # Returns a reader that will step through each value in
      # this range.
      if (step_size > $DataType(0))
        return RangeIteratorAscending<<$DataType>>( first, last, step_size )
      else
        return RangeIteratorDescending<<$DataType>>( first, last, step_size )
      endIf

    method is_contiguous_ascending.Logical:
      # For non-enumerated types:
      #
      # Returns true if this range is both a contiguous integer 
      # interval (3, 4, 5, etc.) and in ascending order.
      return (step_size == $DataType(1))

  METHODS
    method to_List.$DataType[]:
      # Creates and returns a list containing all the values in
      # this range.
      return create_reader.to_List.(ArrayList<<$DataType>>)

    method last.$DataType:
      # Returns correct last value for a contiguous ascending integer interval ONLY.
      return &last

  METHODS
    method to_String.String:
      # Returns a string representation of all the values in this 
      # range.
      local StringBuilder builder()
      local var reader = create_reader
      builder.print( '{' )
      while ( reader.has_another )
        builder.print( reader.read )
        if (reader.has_another) builder.print( ',' )
      endWhile
      builder.print( '}' )
      return builder.to_String
endClass


class RangeLT<<$DataType>> : Range<<$DataType>>
  # Specialized ascending range that spans [first,last) in steps of 
  # 'step_size'.
  #
  # RangeLT objects are normally created by the compiler from 
  # "low..<high" or "low upToLessThan high" expressions.
  METHODS
    method create_reader.Reader<<$DataType>>:
      # Returns a reader that will step through each value in
      # this range.
      return RangeIteratorLT<<$DataType>>( first, last, step_size )

    method last.$DataType:
      # Returns correct last value for a contiguous ascending integer interval ONLY.
      return (&last - 1)
endClass


class RangeGT<<$DataType>> : Range<<$DataType>>
  # Specialized descending range that spans [first,last) in steps of 
  # 'step_size'.
  #
  # RangeGT objects are normally created by the compiler from 
  # "high..>low" or "high downToGreaterThan low" expressions.
  METHODS
    method init( first, last ):
      step_size = $DataType(-1)

    method init( first, last, step_size ):

    method create_reader.Reader<<$DataType>>:
      # Returns a reader that will step through each value in
      # this range.
      return RangeIteratorGT<<$DataType>>( first, last, step_size )
endClass

class RangeGE<<$DataType>> : Range<<$DataType>>
  # Specialized descending range that spans [first,last] in steps of 
  # 'step_size'.
  #
  # RangeGE objects are normally created by the compiler from 
  # "high downTo low" expressions.
  METHODS
    method init( first, last ):
      step_size = $DataType(-1)

    method init( first, last, step_size ):

    method create_reader.Reader<<$DataType>>:
      # Returns a reader that will step through each value in
      # this range.
      return RangeIteratorGE<<$DataType>>( first, last, step_size )
endClass

class RangeIteratorAscending<<$DataType>> : Reader<<$DataType>>
  # A reader that steps through an ascending range
  # of numbers and includes the last value.
  #
  # Created by Range objects.
  PROPERTIES
    next_value, last_value, step_size : $DataType

  METHODS
    method init( $DataType first_value, last_value, step_size ): 
      next_value = first_value

    method create_duplicate.RangeIteratorAscending<<$DataType>>:
      # Handles duplicating this iterator when "duplicate(iterator_obj)" is called.
      return RangeIteratorAscending<<$DataType>>(next_value,last_value,step_size)

    method has_another.Logical:
      # Returns "true" if this reader has another value that can
      # be previewed with peek() or read with read().
      return next_value <= last_value

    method peek.$DataType:
      # Returns the next value that will be returned from read().
      # If there is no next value then a NoNextValueError is thrown.
      if (next_value > last_value) throw NoNextValueError()
      return next_value

    method read.$DataType:
      # Returns the next value from this reader.  If (not has_another)
      # then a NoNextValueError is thrown.
      if (next_value > last_value) throw NoNextValueError()
      local var result = next_value
      next_value += step_size
      return result
endClass

class RangeIteratorDescending<<$DataType>> : Reader<<$DataType>>
  # A reader that steps through a descending range
  # of numbers and includes the last value.
  #
  # Created by Range objects.
  PROPERTIES
    next_value, last_value, step_size : $DataType

  METHODS
    method init( $DataType first_value, last_value, step_size ): 
      next_value = first_value

    method create_duplicate.RangeIteratorDescending<<$DataType>>:
      # Handles duplicating this iterator when "duplicate(iterator_obj)" is called.
      return RangeIteratorDescending<<$DataType>>(next_value,last_value,step_size)

    method has_another.Logical:
      # Returns "true" if this reader has another value that can
      # be previewed with peek() or read with read().
      return next_value >= last_value

    method peek.$DataType:
      # Returns the next value that will be returned from read().
      # If there is no next value then a NoNextValueError is thrown.
      if (next_value < last_value) throw NoNextValueError()
      return next_value

    method read.$DataType:
      # Returns the next value from this reader.  If (not has_another)
      # then a NoNextValueError is thrown.
      if (next_value < last_value) throw NoNextValueError()
      local var result = next_value
      next_value += step_size
      return result
endClass

class RangeIteratorLT<<$DataType>> : Reader<<$DataType>>
  # A reader that steps through an ascending range
  # of numbers and excludes the last value.
  #
  # Created by RangeLT objects.
  PROPERTIES
    next_value, last_value, step_size : $DataType

  METHODS
    method init( $DataType first_value, last_value, step_size ): 
      next_value = first_value

    method create_duplicate.RangeIteratorLT<<$DataType>>:
      # Handles duplicating this iterator when "duplicate(iterator_obj)" is called.
      return RangeIteratorLT<<$DataType>>(next_value,last_value,step_size)

    method has_another.Logical:
      # Returns "true" if this reader has another value that can
      # be previewed with peek() or read with read().
      return next_value < last_value

    method peek.$DataType:
      # Returns the next value that will be returned from read().
      # If there is no next value then a NoNextValueError is thrown.
      if (next_value >= last_value) throw NoNextValueError()
      return next_value

    method read.$DataType:
      # Returns the next value from this reader.  If (not has_another)
      # then a NoNextValueError is thrown.
      if (next_value >= last_value) throw NoNextValueError()
      local var result = next_value
      next_value += step_size
      return result
endClass

class RangeIteratorGT<<$DataType>> : Reader<<$DataType>>
  # A reader that steps through a descending range
  # of numbers and excludes the last value.
  #
  # Created by RangeGT objects.
  PROPERTIES
    next_value, last_value, step_size : $DataType

  METHODS
    method init( $DataType first_value, last_value, step_size ): 
      next_value = first_value

    method create_duplicate.RangeIteratorGT<<$DataType>>:
      # Handles duplicating this iterator when "duplicate(iterator_obj)" is called.
      return RangeIteratorGT<<$DataType>>(next_value,last_value,step_size)

    method has_another.Logical:
      # Returns "true" if this reader has another value that can
      # be previewed with peek() or read with read().
      return next_value > last_value

    method peek.$DataType:
      # Returns the next value that will be returned from read().
      # If there is no next value then a NoNextValueError is thrown.
      if (next_value <= last_value) throw NoNextValueError()
      return next_value

    method read.$DataType:
      # Returns the next value from this reader.  If (not has_another)
      # then a NoNextValueError is thrown.
      if (next_value <= last_value) throw NoNextValueError()
      local var result = next_value
      next_value += step_size
      return result
endClass

class RangeIteratorGE<<$DataType>> : Reader<<$DataType>>
  # A reader that steps through a descending range
  # of numbers and includes the last value.
  #
  # Created by RangeGE objects.
  PROPERTIES
    next_value, last_value, step_size : $DataType

  METHODS
    method init( $DataType first_value, last_value, step_size ): 
      next_value = first_value

    method create_duplicate.RangeIteratorGE<<$DataType>>:
      # Handles duplicating this iterator when "duplicate(iterator_obj)" is called.
      return RangeIteratorGE<<$DataType>>(next_value,last_value,step_size)

    method has_another.Logical:
      # Returns "true" if this reader has another value that can
      # be previewed with peek() or read with read().
      return next_value >= last_value

    method peek.$DataType:
      # Returns the next value that will be returned from read().
      # If there is no next value then a NoNextValueError is thrown.
      if (next_value < last_value) throw NoNextValueError()
      return next_value

    method read.$DataType:
      # Returns the next value from this reader.  If (not has_another)
      # then a NoNextValueError is thrown.
      if (next_value < last_value) throw NoNextValueError()
      local var result = next_value
      next_value += step_size
      return result
endClass


class EnumIterator<<$DataType>>
  # A reader that steps through the enumeration categories between
  # a start and an end value.
  #
  # Created by Range<<$DataType>> objects with an enumeration $DataType.
  PROPERTIES
    next_value, last_value : $DataType

  METHODS
    method init( $DataType first_value, last_value ):
      next_value = first_value

    method create_duplicate.EnumIterator<<$DataType>>:
      # Handles duplicating this iterator when "duplicate(iterator_obj)" is called.
      return EnumIterator<<$DataType>>(next_value,last_value)

    method has_another.Logical: 
      # Returns "true" if this reader has another value that can
      # be previewed with peek() or read with read().
      return next_value isNot null

    method peek.$DataType:
      # Returns the next value that will be returned from read().
      # If there is no next value then a NoNextValueError is thrown.
      if (next_value is null ) throw NoNextValueError()
      return next_value

    method read.$DataType:
      # Returns the next value from this reader.  If (not has_another)
      # then a NoNextValueError is thrown.
      if (next_value is null ) throw NoNextValueError()
      local var result = next_value
      if (result is last_value) next_value = null
      else next_value = next_value.next
      return result

endClass

class CompositeData<<$DataType>> : Readable<<$DataType>>
  # A range made up of ranges - each next value is obtained indirectly
  # from a list of ranges.  For example, {1..3,7..9} creates a
  # CompositeData object whose reader would return the values
  # {1,2,3,7,8,9}.
  #
  # This is relied on by the compiler internally; most programmers 
  # will not need to use it directly.
  PROPERTIES
    ranges : Readable<<$DataType>>[]

  METHODS
    method init( ranges ):

    method create_reader.Reader<<$DataType>>:
      # Returns a reader that can be used to read() this data one 
      # element at a time.
      return CompositeDataReader<<$DataType>>( ranges.create_reader )

    method to_String.String:
      # Returns a string representation of this CompositeData.
      local StringBuilder builder()
      local var reader = create_reader
      builder.print( '{' )
      while ( reader.has_another )
        builder.print( reader.read )
        if (reader.has_another) builder.print( ',' )
      endWhile
      builder.print( '}' )
      return builder.to_String
endClass

class CompositeDataReader<<$DataType>> : Reader<<$DataType>>
  # Reader for a CompositeData.  Utilized by the Slag compiler.
  PROPERTIES
    range_reader : Reader<<Readable<<$DataType>>>>
    cur_range    : Reader<<$DataType>>

  METHODS
    method init( range_reader ):
      if (range_reader.has_another) 
        cur_range = range_reader.read.create_reader
      endIf
      prep_next

    private method init( cur_range, range_reader ):

    method create_duplicate.CompositeDataReader<<$DataType>>:
      # Handles duplicating this iterator when "duplicate(iterator_obj)" is called.
      return CompositeDataReader<<$DataType>>(duplicate(cur_range),duplicate(range_reader))

    method prep_next:
      # Prepares the next value that will be used by peek() and 
      # read().  As a composite range reader, this involves advancing
      # to the next range reader if the current range reader is
      # empty.
      if (cur_range is null) return
      while (not cur_range.has_another)
        if (range_reader.has_another) 
          cur_range = range_reader.read.create_reader
        else
          cur_range = null; return
        endIf
      endWhile

    method has_another.Logical: 
      # Returns "true" if this reader has another value that can
      # be previewed with peek() or read with read().
      return cur_range isNot null

    method peek.$DataType:
      # Returns the next value that will be returned from read().
      # If there is no next value then a NoNextValueError is thrown.
      if (cur_range is null) throw NoNextValueError()
      return cur_range.peek

    method read.$DataType:
      # Returns the next value from this reader.  If (not has_another)
      # then a NoNextValueError is thrown.
      if (cur_range is null) throw NoNextValueError()
      local $DataType result = cur_range.read
      prep_next
      return result
endClass


#=====================================================================
#  Collection readers
#=====================================================================
class ListReader<<$DataType>> : Reader<<$DataType>>
  # A reader that steps through the values in a set of indexed data.
  PROPERTIES
    data   : List<<$DataType>>
    counter, last_exclusive  : Int32
    original_modification_count : Int32

  METHODS
    method init( data, Int32 first_index, Int32 count=-1 ):
      counter  = first_index
      if (count == -1) count = data.count
      last_exclusive = first_index + count;
      if (last_exclusive > data.count) last_exclusive = data.count
      original_modification_count = data.modification_count

    method create_duplicate.ListReader<<$DataType>>:
      # Handles duplicating this iterator when "duplicate(iterator_obj)" is called.
      return ListReader<<$DataType>>(data,counter,last_exclusive-counter)

    method has_another.Logical:
      # Returns "true" if this reader has another value that can
      # be previewed with peek() or read with read().
      if (counter < last_exclusive)
        return true
      else
        # check against original count at end
        if (original_modification_count != data.modification_count) throw ConcurrentModificationError()
        return false
      endIf

    method remaining.Int32:
      # Returns the number of values remaining to be read.
      return last_exclusive - counter

    method available.Int32:
      # Returns the number of values that can be read without 
      # blocking - equivalent to 'remaining' in most cases.
      return remaining

    method peek.$DataType:
      # Returns the next value that will be returned from read().
      return data[counter]

    method read.$DataType:
      # Returns the next value from this reader.
      local var result = data[counter]
      counter++
      return result

    method position.Int32:
      # Returns the zero-based position property of this reader.  The
      # position is equivalent to the number of values read in so far.
      return counter

    method position( Int32 new_position ):
      # Sets the zero-based position property of this reader.
      #
      # Requires:
      #   new_position >= 0 and new_position < count
      counter = new_position;
endClass

class IndexedDataReverseReader<<$DataType>> : ListReader<<$DataType>>
  # A reader that steps through the values in a set of indexed data from last to first.
  METHODS
    method init( data ): 
      original_modification_count = data.modification_count
      counter = data.count - 1

    method init( data, counter, last_exclusive, original_modification_count ):

    method create_duplicate.ListReader<<$DataType>>:
      # Handles duplicating this iterator when "duplicate(iterator_obj)" is called.
      return IndexedDataReverseReader<<$DataType>>(data,counter,last_exclusive,
          original_modification_count)

    method has_another.Logical:
      # Returns "true" if this reader has another value that can
      # be previewed with peek() or read with read().
      if (counter >= 0)
        return true
      else
        # check against original count at end
        if (original_modification_count != data.modification_count) throw ConcurrentModificationError()
        return false
      endIf

    method remaining.Int32:
      # Returns the number of values remaining to be read.
      return counter + 1

    method peek.$DataType:
      # Returns the next value that will be returned from read().
      # If there is no next value then a NoNextValueError is thrown.
      
      if (counter < 0) throw NoNextValueError()
      return data[counter]

    method read.$DataType:
      # Returns the next value from this reader.  If (not has_another)
      # then a NoNextValueError is thrown.
      if (counter < 0) throw NoNextValueError()
      local var result = data[counter]
      counter--
      return result

endClass

class ArrayReader<<$DataType>> : Reader<<$DataType>>
  # A reader that steps through the values in an array.
  # Allows for faster reads than an ListReader.
  PROPERTIES
    # These properties are mirrored as C-side structs - don't change
    # the type or order!
    data : Array<<$DataType>>
    collection : Collection<<$DataType>>
    counter, last_exclusive  : Int32
    original_modification_count : Int32

  METHODS
    method init( collection, data, Int32 first_index, Int32 count=-1 ):
      counter  = first_index
      if (count == -1) count = collection.count
      last_exclusive = first_index + count;
      if (last_exclusive > collection.count) last_exclusive = collection.count
      original_modification_count = collection.modification_count

    method create_duplicate.ArrayReader<<$DataType>>:
      # Handles duplicating this iterator when "duplicate(iterator_obj)" is called.
      return ArrayReader<<$DataType>>(collection,data,counter,last_exclusive-counter)

    method has_another.Logical:
      # Returns "true" if this reader has another value that can
      # be previewed with peek() or read with read().
      if (counter < last_exclusive)
        return true
      else
        # check against original count at end
        if (original_modification_count != collection.modification_count) throw ConcurrentModificationError()
        return false
      endIf

    method remaining.Int32:
      # Returns the number of values remaining to be read.
      return last_exclusive - counter

    method available.Int32:
      # Returns the number of values that can be read without 
      # blocking - equivalent to 'remaining' in most cases.
      return remaining

    method peek.$DataType:
      # Returns the next value that will be returned from read().
      return data[counter]

    method read.$DataType:
      # Returns the next value from this reader.  If (not has_another)
      # then a NoNextValueError is thrown.
      local var result = data[counter]
      counter++
      return result

    method position.Int32:
      # Returns the zero-based position property of this reader.  The
      # position is equivalent to the number of values read in so far.
      return counter

    method position( Int32 new_position ):
      # Sets the zero-based position property of this reader.
      #
      # Requires:
      #   new_position >= 0 and new_position < count
      counter = new_position;
      if (counter < 0 or counter > last_exclusive) throw OutOfBoundsError(counter)
endClass

class ArrayReverseReader<<$DataType>> : ArrayReader<<$DataType>>
  # A reader that steps through the values in a set of indexed data from last to first.
  METHODS
    method init( collection, data ): 
      original_modification_count = collection.modification_count
      counter = collection.count - 1

    method init( collection, data, counter, last_exclusive, original_modification_count ):

    method create_duplicate.ArrayReader<<$DataType>>:
      # Handles duplicating this iterator when "duplicate(iterator_obj)" is called.
      return ArrayReverseReader<<$DataType>>(collection,data,counter,last_exclusive,
          original_modification_count)

    method has_another.Logical:
      # Returns "true" if this reader has another value that can
      # be previewed with peek() or read with read().
      if (counter >= 0)
        return true
      else
        # check against original count at end
        if (original_modification_count != collection.modification_count) throw ConcurrentModificationError()
        return false
      endIf

    method remaining.Int32:
      # Returns the number of values remaining to be read.
      return counter + 1

    method peek.$DataType:
      # Returns the next value that will be returned from read().
      # If there is no next value then a NoNextValueError is thrown.
      
      if (counter < 0) throw NoNextValueError()
      return data[counter]

    method read.$DataType:
      # Returns the next value from this reader.  If (not has_another)
      # then a NoNextValueError is thrown.
      if (counter < 0) throw NoNextValueError()
      local var result = data[counter]
      --counter
      return result

endClass

class StringReader : Reader<<Char>>
  # A reader that steps through the values in a string.
  PROPERTIES
    string : String
    counter, last_exclusive  : Int32

  METHODS
    method init( string, Int32 first_index, Int32 count=-1 ):
      counter  = first_index
      if (count == -1) count = string.count
      last_exclusive = first_index + count;
      if (last_exclusive > string.count) last_exclusive = string.count

    method create_duplicate.StringReader:
      # Handles duplicating this iterator when "duplicate(iterator_obj)" is called.
      return StringReader(string,counter,last_exclusive-counter)

    method has_another.Logical:
      # Returns "true" if this reader has another value that can
      # be previewed with peek() or read with read().
      return (counter < last_exclusive)

    method remaining.Int32:
      # Returns the number of values remaining to be read.
      return last_exclusive - counter

    method available.Int32:
      # Returns the number of values that can be read without 
      # blocking - equivalent to 'remaining' in most cases.
      return remaining

    method peek.Char:
      # Returns the next value that will be returned from read().
      return string[counter]

    method read.Char:
      # Returns the next value from this reader.  If (not has_another)
      # then a NoNextValueError is thrown.
      local var result = string[counter]
      counter++
      return result

    method position.Int32:
      # Returns the zero-based position property of this reader.  The
      # position is equivalent to the number of values read in so far.
      return counter

    method position( Int32 new_position ):
      # Sets the zero-based position property of this reader.
      #
      # Requires:
      #   new_position >= 0 and new_position < count
      counter = new_position;
      if (counter < 0 or counter > last_exclusive) throw OutOfBoundsError(counter)
endClass

class StringReverseReader : StringReader
  # A reader that steps through the values in a String from last to first.
  METHODS
    method init( string ): 
      counter = string.count - 1

    method init( string, counter, last_exclusive ):

    method create_duplicate.StringReader:
      # Handles duplicating this iterator when "duplicate(iterator_obj)" is called.
      return StringReverseReader(string,counter,last_exclusive)

    method has_another.Logical:
      # Returns "true" if this reader has another value that can
      # be previewed with peek() or read with read().
      return (counter >= 0)

    method remaining.Int32:
      # Returns the number of values remaining to be read.
      return counter + 1

    method peek.Char:
      # Returns the next value that will be returned from read().
      # If there is no next value then a NoNextValueError is thrown.
      
      if (counter < 0) throw NoNextValueError()
      return string[counter]

    method read.Char:
      # Returns the next value from this reader.  If (not has_another)
      # then a NoNextValueError is thrown.
      if (counter < 0) throw NoNextValueError()
      local var result = string[counter]
      --counter
      return result

endClass


#=====================================================================
#  RandomNumberGenerator
#=====================================================================
singleton class RandomNumberGenerator
  # This random number generator produces evenly distributed 
  # pseudo-random values.  
  #
  # Use any the following methods:
  #
  #   random_Real64().Real64:
  #     Returns a real number n where 0.0 < n < 1.0.
  #
  #   random_Real64(low,high).Real64:
  #     Returns a real number n where low < n < high.
  #
  #   random_Int32().Int32
  #     Returns a number between 0 and 0xffffffff (-1).
  #
  #   random_Int32(limit).Int32
  #     Returns an integer n where 0 <= n < limit.
  #
  #   random_Int32(low,high).Int32
  #     Returns an integer n where low <= n <= high.
  #
  #   random_Logical().Logical:
  #     Returns either "true" or "false" with a 50/50 chance.
  #
  # You may create a RandomNumberGenerator object with a 'seed' 
  # value; generators created with the same seed always return
  # the same sequence of random numbers.
  #
  # Underneath, the RandomNumberGenerator operates on a 48-bit 
  # integer using the linear congruence formula with most of
  # the "drand48" parameters:
  #
  #   next = (a * prev + c) mod (2^48)
  #
  # Where a=0x5DEECE66D, c=11, and bits 31:0 of
  # 'next' are retrieved with each read call.
  PROPERTIES
    next_random : Int64
      # The underlying raw value that will be filtered and 
      # returned by a read.

    initial_seed : Int64

  METHODS
    method init:
      # Since this is a singleton we need a default constructor
      # if we want anything to happen.
      init( time_ms.left_shifted(32) ~ time_ms )

    method init( initial_seed ):
      # Initializes this random number generator with the given
      # initial_seed (default: the current time in milliseconds).
      # Different seed values produce different sequences of 
      # pseudo-random numbers.
      rewind

    method init( RandomNumberGenerator existing ):
      # Initializes this RandomNumberGenerator to be a copy of
      # an existing random number generator.
      initial_seed = existing.initial_seed
      next_random = existing.next_random

    method create_duplicate.RandomNumberGenerator:
      # Handles duplicating this iterator when "duplicate(iterator_obj)" is called.
      return RandomNumberGenerator(this)

    method rewind:
      # Rewinds this generator.  It will now produce the same sequence of
      # values as it did when it was first created.
      next_random = initial_seed
      advance_random

    method advance_random.Int64:
      # Calculates the internal 'next_random' raw integer.
      next_random = (0x5deece66d * next_random + 11)
      return next_random

    method random_Real64.Real64: 
      # Returns a normalized, evenly distributed random real number in
      # the range (0.0,1.0) exclusive (does not include 0.0 or 1.0).
      return (((advance_random & Int64(0xffffffffffff)) + 1.0) / (2.0 ^ 48.0 + 1.0))

    method random_Real64( Real64 low, Real64 high ).Real64: 
      # Returns an evenly distributed random real number in
      # the range (low,high) exclusive (does not include low or high).
      return (random_Real64 * (high-low)) + low

    method random_Int32.Int32: 
      # Returns a normalized, evenly distributed random integer in
      # the range [-2^31,2^31-1] inclusive.
      return Int32(random_Real64 * 2.0^32 - 2.0^31)

    method random_Int32( Int32 limit ).Int32: 
      # Returns an evenly distributed random integer in
      # the range [0,limit) - includes 0 but does not include limit.
      #
      # Example:
      #   println( random_Int32(100) )  #prints a number 0..99
      return Int32(random_Real64 * limit)

    method random_Int32( Int32 low, Int32 high ).Int32: 
      # Returns a random integer between low and high, inclusive.
      return Int32(random_Real64 * (high-low+1)) + low

    method random_Logical.Logical:
      # Returns either "true" or "false" with equal likelihood.
      return (random_Real64 < 0.5)
endClass



#=====================================================================
#  Readers and Writers for Input/Output
#=====================================================================
requisite class StdOutWriter : TextWriter
  # Defines a TextWriter that prints to the standard output.
  METHODS
    method init:
    method write( Char ch ):   native
    method write( String st ): native
    method print( Char ch ):   native
    method print( String st ): native
    method flush: native
endClass


requisite class StdInReader : Reader<<Char>>
  # A Reader<<Char>> that reads from the standard input.
  #
  # Technical note: unlike most readers, StdInReader fetches its
  # next value on demand rather than preparing the next one ahead
  # of time.  This is because any peek() or read() may be a
  # blocking call.

  PROPERTIES
    next             : Char
    has_next = false : Logical

  METHODS
    method init:

    method has_another.Logical:
      # Returns "true" - the standard input always has another
      # value to read, although trying to peek() or read() the
      # value may block until it becomes available.
      return true

    method peek.Char: 
      # Returns the character that will be returned from read().
      # This call blocks until a character becomes available.
      # There is no way to check and see if a character is available
      # before you call peek() or read().
      if (not has_next) has_next = prep_next
      return next

    method read.Char:
      # Reads the next character of input from stdin (usually the
      # keyboard).  This call blocks until a character becomes 
      # available.
      if (has_next) has_next = false; return next
      prep_next
      return next

    method native_read_char.Char: native

    method prep_next.Logical:
      # Prepares the next value that will be used by peek() and 
      # read().  Returns "true" if there is another value, "false"
      # if not.
      next = native_read_char
      return true

    method available.Int32:
      if (has_next) return 1
      else          return 0
endClass

class UTF8Reader : Reader<<Char>>, RequiresCleanup
  PROPERTIES
    src      : Reader<<Char>>
    next     : Char
    has_next : Logical
    count    : Int32

  METHODS
    method init( src ):
      prep_next

    method init( Reader<<Byte>> bytes ):
      init( CharReader(bytes) )

    private method prep_next:
      if (src.has_another)
        next = src.read

        if ((next & 0x80) != 0)
          local Int32 ch2 = src.read

          if ((next & 0x20) == 0)
            # %110xxxxx 10xxxxxx
            next  &= 0x1f
            ch2 &= 0x3f
            next = next.left_shifted(6) | ch2
          else
            # %1110xxxx 10xxxxxx 10xxxxxx
            local Int32 ch3 = src.read
            next  &= 15
            ch2 &= 0x3f
            ch3 &= 0x3f
            next = next.left_shifted(12) | ch2.left_shifted(6) | ch3
          endIf
        endIf

        has_next = true
        ++count

      else
        has_next = false
      endIf

    method close:
      src.close

    method clean_up:
      close
      insertUnderlying

    method has_another.Logical:
      return has_next

    method peek.Char:
      # Returns the next value that will be returned from read().
      # If there is no next value then a NoNextValueError is thrown.
      return next

    method read.Char:
      # Returns the next character from the associated file.  If there
      # is no next character than a NoNextValueError is thrown.  Once
      # the last character is read the file is automatically closed.
      local var result = next
      prep_next
      return result

    method available.Int32:
      # Returns 1 if there is at least 1 more character available.
      if (has_next) return 1
      else return 0

    method remaining.Int32:
      # Returns 1 if there is at least 1 more character available.
      if (has_next) return 1
      else return 0

    method skip( Int32 skip_count=1 ):
      # Skips over the next 'skip_count' number of characters in
      # this file.  The skip count must be non-negative.
      forEach (1..skip_count) read

    method position.Int32:
      # Returns the position of this file - equivalent to the
      # number of characters read so far.
      return count

    method position( Int32 new_position ):
      # Sets this position of this file.  File readers can only be
      # repositioned further on in the file, so new_position must
      # be >= position.
      throw UnsupportedOperationError()

    method to_List.Char[]:
      local Char[] result()
      forEach (ch in this) result.add(ch)
      return result

endClass

class UTF8Writer : TextWriter, RequiresCleanup
  # Subclass of TextWriter that wraps a Writer<<Char>> and prints unicode 
  # characters as UTF8-encoded bytes.
  PROPERTIES
    dest  : Writer<<Char>>
    count : Int32

  METHODS
    method init( dest ):

    method close:
      dest.close
    
    method clean_up:
      close
      insertUnderlying

    method write( Char ch ):
      # Writes 'value encoded as UTF8 bytes.
      ++count
      if (ch < 0x80)
        # %0xxxxxxx
        dest.write( ch )

      elseIf (ch < 0x800)
        # %110xxxxx 10xxxxxx
        dest.write( Char(((ch.right_shifted(6)) & 0x1f) | 0xc0) )
        dest.write( Char((ch & 0x3f) | 0x80) )

      else
        # %1110xxxx 10xxxxxx 10xxxxxx
        dest.write( Char(((ch.right_shifted(12)) & 15) | 0xe0) )
        dest.write( Char(((ch.right_shifted(6)) & 0x3f) | 0x80) )
        dest.write( Char((ch & 0x3f) | 0x80) )

      endIf

    method position.Int32:
      # This property-read returns the position of the file, 
      # equivalent to the number of characters (not bytes) that have been written
      # thus far.
      return count

endClass


#=====================================================================
#  Reader/Writer Wrappers
#=====================================================================
class CharReader : Reader<<Char>>
  PROPERTIES
    src : Reader<<Byte>>

  METHODS
    method init( src ):

    method has_another.Logical:
      return src.has_another

    method peek.Char:
      return src.peek.(Char)

    method read.Char:
      return src.read.(Char)
endClass

class LineReader : Reader<<String>>
  # Wraps an existing character reader and reads lines at a time,
  # discarding CRLF characters.
  #
  # For example, to print every line of a file with a line number:
  #   local Int32 number = 1
  #   forEach (line in LineReader(File("test.slag")))
  #     println( "$(6)  $" (number,line) )
  #     number++
  #   endForEach
  PROPERTIES
    src  : Reader<<Char>>
    next : String

  METHODS
    method init(src):
      prep_next

    method has_another.Logical:
      return next?

    method peek.String:
      return next

    method read.String:
      local var result = next
      prep_next
      return result

    method prep_next:
      # Prepares the next value that will be used by peek() and 
      # read().
      if (not src.has_another) next=null; return

      local StringBuilder buffer()
      forEach (ch in src)
        which (ch)
          case 10: escapeForEach
          case 13: src.consume(10); escapeForEach
        endWhich
        buffer.print(ch)
      endForEach
      next = buffer.to_String
endClass


#=====================================================================
#  ParseReader classes
#=====================================================================
compound ParsePos( Int32 line, Int32 column )
  # Defines a ParsePosition with a line and a column.

augment TextWriter
  METHODS
    method print( ParsePos p ):
      # Prints the given ParsePos in text form.
      print( to_String(p) )

    method println( ParsePos p ):
      # Prints the given ParsePos in text form and advances the 
      # cursor to the next line.
      println( to_String(p) )
endAugment

augment Global
  METHODS
    method print( ParsePos p ):
      # Prints the given ParsePos to stdout.
      print( to_String(p) )

    method println( ParsePos p ):
      # Prints the given ParsePos to stdout and advances the 
      # cursor to the next line.
      println( to_String(p) )

    method to_String( ParsePos p ).String:
      # Returns a string representation of the given ParsePos.
      return "line $, column $" (p.line,p.column)

    method format_string( ParsePos p, Int32 whole_digits, Int32 decimal_digits, Char fill_char=' ' ).String:
      # Returns a formatted string representation of the given 
      # ParsePos.
      return format_string( to_String(p), whole_digits, decimal_digits, fill_char )
endAugment

compound ParseReaderMark( Int32 line, Int32 column, Int32 pos, Int32 remaining )

requisite class ParseReader : Reader<<Char>>
  # Creates a text reader that tracks the current line and
  # column, defines a certain number of spaces per tab, and can
  # replace tabs with spaces.  Also converts CR, LF, and CRLF as 
  # into single LF characters ("\n", Unicode 10).
  #
  # ParseReader is optimized for fast parsing.  As a consequent limitation,
  # the string passed to consume(String) may not contain any tabs.

  PROPERTIES
    # NOTE: don't change this data structure without changing the native layer code.

    line=1   : Int32
      # The current line number.  Starts at "1" and is incremented
      # at each LF.

    column=1 : Int32
      # The current column.  Starts at "1", is incremented after each
      # read, and is reset to "1" at each LF.

    pos              : Int32
    remaining        : Int32
    spaces_per_tab=2 : Int32

    data : Array<<Char>>

  METHODS
    method init( Reader<<Char>> reader ):
      local var list = reader.to_List
      if (list notInstanceOf ArrayList<<Char>>)
        local Char[] new_list( list.count )
        forEach (ch in list) new_list.add(ch)
        list = new_list
      endIf
      init( list.(ArrayList<<Char>>) )

      #method init( Char[] list ):
      #init( list.(ArrayList<<Char>>) )

    method init( ArrayList<<Char>> list ):
      data = list.data
      remaining = list.count
      prep_data

    method init( data ):
      remaining = data.count
      prep_data

    method init( String text ):
      data = text.to_Array
      remaining = data.count
      prep_data

    private method prep_data:   native
      # Makes a copy of 'data' and prepares it for reading.

    method has_another.Logical: native
    method peek.Char:           native
    method peek(Int32 n).Char:  native
    method read.Char:           native
    method consume(Char ch).Logical:   native
    method consume(String st).Logical: native

    method must_consume( Char ch ):
      if (not consume(ch)) throw NoNextValueError( "'$' expected." (ch) )

    method must_consume( String st ):
      if (not consume(st)) throw NoNextValueError( //"$" expected.// )

    method consume_ws.Logical:
      if (not consume(' ')) return false
      while (consume(' ')) noAction
      return true

    method cur_pos.ParsePos:
      # Returns the current parse position - the current line and 
      # column after every character read so far.
      return ParsePos(line,column)

    method remaining.Int32:
      return &remaining

    method save_position.ParseReaderMark:
      return ParseReaderMark( line, column, pos, remaining )

    method restore_position( ParseReaderMark mark ):
      line = mark.line
      column = mark.column
      pos = mark.pos
      remaining = mark.remaining
endClass


#=====================================================================
#  HashTable
#=====================================================================
class GenericHashTable<<$KeyType,$ValueType>>
  # Internal use - see class HashTable.
  #
  # Defines the actual implementation of a HashTable.  Every HashTable
  # that stores maps to or from a reference type will be have a
  # GenericHashTable that maps to or from type Object.
  PROPERTIES
    bins : HashTableBin<<$KeyType,$ValueType>>[]

    num_entries = 0 : Int32

    average_bin_size : Real64
      # average_bin_size of 3, the table will expand once there 
      # are 3 items in each bin (3*16=48 items total, 48/16 bins=3 
      # avg) or when a single bin has 48 items (48 / 16 = 3 avg).  
      # This value is used to calculate the max_entries before the 
      # table expands.

    max_entries : Real64
      # Recalculated from average_bin_size each time the table
      # expands.

    max_bins = 512 : Int32
      # The number of bins (default: 512 ) at which the table will 
      # stop auto-expanding # and instead continue to fill the 
      # existing bins however large they may get.

    hash_mask : Int32
      # Internal use.  Set to the number of bins-1.  E.g. for 16 bins
      # the mask is 15, since hash_code & 15 -> 0..15

  METHODS
    method init:
      # Default initializer, necessary if you ever make a singleton class
      # that extends HashTable.
      init( 16 )

    method init( Int32 num_bins, average_bin_size=3.0 ):
      # Initializes this hash table with the given number of bins
      # (default 16) and the given average_bin_size (default 3.0).
      num_bins = num_bins.rounded_up_to_power_of_two
      hash_mask = num_bins - 1
      max_entries = num_bins * average_bin_size
      bins = HashTableBin<<$KeyType,$ValueType>>[]()
      forEach (1..num_bins) 
        bins.add( HashTableBin<<$KeyType,$ValueType>>(average_bin_size) )
      endForEach

    method clear:
      # Removes all mappings from this hash table.
      num_entries = 0
      forEach (bin in bins) bin.clear

    method count.Int32:
      # Returns the number of mappings in this table.
      return num_entries

    method set( $KeyType key, $ValueType value ):
      # Associates the given value with the given key.  When get() is
      # called with 'key', 'value' will be returned.

      if (num_entries == max_entries) expand_table
      if (get_bin(key).add_entry(key, value)) num_entries++

    method set( Mapping<<$KeyType,$ValueType>> entry ):
      # Associates the given value with the given key.  When get() is
      # called with 'key', 'value' will be returned.

      if (num_entries == max_entries) expand_table
      if (get_bin(entry.key).add_entry(entry)) num_entries++

    method get( $KeyType key ).$ValueType:
      # Retrieves the value (previously mapped with set()) associated 
      # with 'key'.  Throws a NoSuchElementError if 'key' has not been
      # defined.
      local var entry = get_bin(key).find_entry(key)
      if (entry is null) 
        #throw NoSuchElementError(to_String(key))
        local $ValueType null_result
        return null_result
      endIf
      return entry.value

    method find( $KeyType key ).Mapping<<$KeyType,$ValueType>>:
      # Finds the underlying Mapping that defines the mapping
      # between 'key' and 'value'.  Returns a null reference if no
      # mapping is present.  Useful for optimizing conditional table
      # operations.
      #
      # Example without find():
      #   if (table.contains(id))
      #     person = table[id]
      #   endIf
      #
      # Example with find() - a bit faster:
      #   local var mapping = table.find(id)
      #   if (mapping isNot null)
      #     person = mapping.value
      #   endIf
      return get_bin(key).find_entry( key )

    method contains( $KeyType key ).Logical:
      # Returns "true" if 'key' has an associated value in this table
      # that can be retrieved with get().

      local var entry = get_bin(key).find_entry(key)
      return (entry isNot null)

    method remove( $KeyType key ).$ValueType:
      # Removes the mapping between 'key' and its value from this table.
      # Returns null/zero/false if 'key' has not been defined.

      local var bin = get_bin(key)
      local Int32 index = bin.index_of_entry( key )
      if (index == -1)
        local $ValueType null_result
        return null_result
      endIf
      num_entries--
      return bin.entries.remove( index ).value

    method remove( Reader<<$KeyType>> reader ):
      forEach (key in reader) remove(key)

    method get_bin( $KeyType key ).HashTableBin<<$KeyType,$ValueType>>:
      return bins[ key.hash_code & hash_mask ]

    method add( GenericHashTable<<$KeyType,$ValueType>> other ):
      # Adds all entries in the compatible hash table to this hash table.
      forEach (bin in other.bins)
        forEach (entry in bin.entries) this[entry.key] = entry.value
      endForEach

    method expand_table:
      # Resizes this hash table to have double the number of bins as
      # before.
      if (bins.count >= max_bins) return

      # Create a temporary table and add all my values to it.  We don't
      # use add() so that we can optimize by avoiding duplication and 
      # keeping the 'entry' objects intact.
      local GenericHashTable<<$KeyType,$ValueType>> new_table( bins.count * 2, average_bin_size )
      forEach (bin in bins)
        forEach (entry in bin.entries) new_table.set( entry )
      endForEach

      # Copy its info back as my own
      bins = new_table.bins
      max_entries = new_table.max_entries
      hash_mask = new_table.hash_mask

    method to_String.String:
      # Returns a string representation of this hashtable.
      return mappings.to_String

    method create_reader.Reader<<$ValueType>>:
      return values

    method keys.Reader<<$KeyType>>:
      # Returns a reader that iterates through this hash table's keys.
      # These are not guaranteed to be an any particular order.
      #
      # Example:
      #   local HashTable<<String,Int32>> ages()
      #   ages["Abe"] = 34
      #   ages["Murphy"] = 30
      #   ages["Matt"] = 28
      #   forEach (name in ages.keys)
      #     println( "$ is $ years old." (name,ages[name]) )
      #       # prints:
      #       #  Abe is 34 years old.
      #       #  Matt is 28 years old.
      #       #  Murphy is 30 years old.
      #   endForEach
      return HashTableKeyReader<<$KeyType,$ValueType>>( bins.create_reader )

    method values.Reader<<$ValueType>>:
      # Returns a reader that iterates through this hash table's values.
      # These are not guaranteed to be an any particular order.
      return HashTableValueReader<<$KeyType,$ValueType>>( bins.create_reader )

    method mappings.Reader<<Mapping<<$KeyType,$ValueType>>>>:
      # Returns a reader that returns each (key,value) mapping in this
      # HashTable.
      #
      # Example:
      #   forEach (mapping in table.mappings)
      #     println( "$:$" (mapping.key,mapping.value) )
      #   endForEach
      return HashTableMappingReader<<$KeyType,$ValueType>>( bins.create_reader )
endClass

class HashTableBase<<$KeyType,$ValueType,$ActualKeyType,$ActualValueType>> : Readable<<$ValueType>>
  PROPERTIES
    data : GenericHashTable<<$ActualKeyType,$ActualValueType>>

  METHODS
    method init:
      # Default initializer, necessary if you ever make a singleton class
      # that extends HashTable.
      data = GenericHashTable<<$ActualKeyType,$ActualValueType>>(16)

    method init( Int32 num_bins, Real64 average_bin_size=3.0 ):
      # Initializes this hash table with the given number of bins
      # (default 16) and the given average_bin_size (default 3.0).
      data = GenericHashTable<<$ActualKeyType,$ActualValueType>>(num_bins,average_bin_size)

    method create_duplicate.HashTable<<$KeyType,$ValueType>>:
      local HashTable<<$KeyType,$ValueType>> new_table(data.bins.count,data.average_bin_size)
      new_table.data.add(data)
      return new_table

    method clear:
      # Removes all mappings from this hash table.
      data.clear

    method count.Int32:
      # Returns the number of mappings in this table.
      return data.count

    method set( $KeyType key, $ValueType value ):
      # Associates the given value with the given key.  When get() is
      # called with 'key', 'value' will be returned.
      data.set(key,value)

    method set( Mapping<<$KeyType,$ValueType>> entry ):
      # Associates the given value with the given key.  When get() is
      # called with 'key', 'value' will be returned.
      data.set(entry coerceAs Mapping<<$ActualKeyType,$ActualValueType>>)

    method get( $KeyType key ).$ValueType:
      # Retrieves the value (previously mapped with set()) associated 
      # with 'key'.  Throws a NoSuchElementError if 'key' has not been
      # defined.
      return data.get(key) coerceAs $ValueType

    method find( $KeyType key ).Mapping<<$KeyType,$ValueType>>:
      # Finds the underlying Mapping that defines the mapping
      # between 'key' and 'value'.  Returns a null reference if no
      # mapping is present.  Useful for optimizing conditional table
      # operations.
      #
      # Example without find():
      #   if (table.contains(id))
      #     person = table[id]
      #   endIf
      #
      # Example with find() - a bit faster:
      #   local var mapping = table.find(id)
      #   if (mapping isNot null)
      #     person = mapping.value
      #   endIf
[if defined(WP7)]
      local var mapping = data.find(key)
      return Mapping<<$KeyType,$ValueType>>( mapping.key, mapping.value )
[else]
      return data.find(key) coerceAs Mapping<<$KeyType,$ValueType>>
[endIf]

    method contains( $KeyType key ).Logical:
      # Returns "true" if 'key' has an associated value in this table
      # that can be retrieved with get().
      return data.contains(key)

    method remove( $KeyType key ).$ValueType:
      # Removes the mapping between 'key' and its value from this table.
      # Throws a NoSuchElementError if 'key' has not been defined.
      return data.remove(key) coerceAs $ValueType

    method remove( Reader<<$KeyType>> reader ):
      data.remove(reader)

    method add( HashTable<<$KeyType,$ValueType>> other ):
      data.add(other.data)

    method expand_table:
      data.expand_table

    method to_String.String:
      # Returns a string representation of this hashtable.
      return data.to_String

    method create_reader.Reader<<$ValueType>>:
      return values

    method keys.Reader<<$KeyType>>:
      # Returns a reader that iterates through this hash table's keys.
      # These are not guaranteed to be an any particular order.
      #
      # Example:
      #   local HashTable<<String,Int32>> ages()
      #   ages["Abe"] = 34
      #   ages["Murphy"] = 30
      #   ages["Matt"] = 28
      #   forEach (name in ages.keys)
      #     println( "$ is $ years old." (name,ages[name]) )
      #       # prints:
      #       #  Abe is 34 years old.
      #       #  Matt is 28 years old.
      #       #  Murphy is 30 years old.
      #   endForEach
      return CoerceReader<<$KeyType>>( data.keys )

    method values.Reader<<$ValueType>>:
      # Returns a reader that iterates through this hash table's values.
      # These are not guaranteed to be an any particular order.
      return CoerceReader<<$ValueType>>( data.values )

    method mappings.Reader<<Mapping<<$KeyType,$ValueType>>>>:
      # Returns a reader that returns each (key,value) mapping in this
      # HashTable.
      #
      # Example:
      #   forEach (mapping in table.mappings)
      #     println( "$:$" (mapping.key,mapping.value) )
      #   endForEach
      local Mapping<<$KeyType,$ValueType>>[] list(count)
      forEach (m in data.mappings)
        list.add( m coerceAs Mapping<<$KeyType,$ValueType>> )
      endForEach
      return list.create_reader
endClass

class HashTable<<$KeyType,$ValueType>>;

augment HashTable<<reference,reference>>         : HashTableBase<<$KeyType,$ValueType,Object,Object>>;
augment HashTable<<reference,non-reference>>     : HashTableBase<<$KeyType,$ValueType,Object,$ValueType>>;
augment HashTable<<non-reference,reference>>     : HashTableBase<<$KeyType,$ValueType,$KeyType,Object>>;
augment HashTable<<non-reference,non-reference>> : HashTableBase<<$KeyType,$ValueType,$KeyType,$ValueType>>;

class CoerceReader<<$ToType>> : Reader<<$ToType>>
  METHODS
    method init(src):
    method has_another.Logical: return src.has_another
    method peek.$ToType:        return src.peek coerceAs $ToType
    method read.$ToType:        return src.read coerceAs $ToType
endClass

augment CoerceReader<<reference>>
  PROPERTIES
    src : Reader<<Object>>
endAugment

augment CoerceReader<<primitive>>
  PROPERTIES
    src : Reader<<$ToType>>
endAugment

augment CoerceReader<<compound>>
  PROPERTIES
    src : Reader<<$ToType>>
endAugment


class Mapping<<$KeyType,$ValueType>>
  # Associates a key with a value.  Used in HashTable and related classes.
  PROPERTIES
    key   : $KeyType
    value : $ValueType

  METHODS
    method init( key, value ):

    method to_String.String:
      return "$:$" (key,value)
endClass



class HashTableKeyReader<<$KeyType,$ValueType>> : Reader<<$KeyType>>
  # Reader that iterates through a HashTable's keys.
  PROPERTIES
    bins    : Reader<<HashTableBin<<$KeyType,$ValueType>>>>
    entries : Reader<<Mapping<<$KeyType,$ValueType>>>>

  METHODS
    method init( bins ):
      if (bins.has_another) 
        entries = bins.read.entries.create_reader
      endIf
      prep_next

    method prep_next:
      # Prepares the next value that will be used by peek() and 
      # read(). 
      if (entries is null) return
      while (not entries.has_another)
        if (bins.has_another) 
          entries = bins.read.entries.create_reader
        else
          entries = null; return
        endIf
      endWhile

    method has_another.Logical: 
      # Returns "true" if this reader has another value that can
      # be previewed with peek() or read with read().
      return entries isNot null

    method peek.$KeyType:
      # Returns the next value that will be returned from read().
      # If there is no next value then a NoNextValueError is thrown.
      return entries.peek.key

    method read.$KeyType:
      # Returns the next value from this reader.  If (not has_another)
      # then a NoNextValueError is thrown.
      local $KeyType result = entries.read.key
      prep_next
      return result
endClass

class HashTableMappingReader<<$KeyType,$ValueType>> : Reader<<Mapping<<$KeyType,$ValueType>>>>
  # Reader that iterates through a HashTable's mappings.
  PROPERTIES
    bins    : Reader<<HashTableBin<<$KeyType,$ValueType>>>>
    entries : Reader<<Mapping<<$KeyType,$ValueType>>>>

  METHODS
    method init( bins ):
      if (bins.has_another) 
        entries = bins.read.entries.create_reader
      endIf
      prep_next

    method prep_next:
      # Prepares the next value that will be used by peek() and 
      # read(). 
      if (entries is null) return
      while (not entries.has_another)
        if (bins.has_another) 
          entries = bins.read.entries.create_reader
        else
          entries = null; return
        endIf
      endWhile

    method has_another.Logical: 
      # Returns "true" if this reader has another value that can
      # be previewed with peek() or read with read().
      return entries isNot null

    method peek.Mapping<<$KeyType,$ValueType>>:
      # Returns the next value that will be returned from read().
      # If there is no next value then a NoNextValueError is thrown.
      return entries.peek

    method read.Mapping<<$KeyType,$ValueType>>:
      # Returns the next value from this reader.  If (not has_another)
      # then a NoNextValueError is thrown.
      local var result = entries.read
      prep_next
      return result
endClass


class HashTableBin<<$KeyType,$ValueType>>
  # Internal use.  A linked list of key/value mappings for a given
  # hashcode bin.
  PROPERTIES
    entries : Mapping<<$KeyType,$ValueType>>[]

  METHODS
    method init( Int32 initial_capacity ):
      entries = ArrayList<<Mapping<<$KeyType,$ValueType>>>>( initial_capacity )

    method clear:
      entries.clear

    method index_of_entry( $KeyType key ).Int32:
      forEach (index of entries)
        if (entries[index].key == key) return index
      endForEach
      return -1

    method find_entry( $KeyType key ).Mapping<<$KeyType,$ValueType>>:
      local var index = index_of_entry( key )
      if (index == -1) return null
      return entries[ index ]

    method add_entry( $KeyType key, $ValueType value ).Logical:
      local var existing = find_entry( key )
      if (existing is null)
        entries.add( Mapping<<$KeyType,$ValueType>>(key,value) )
        return true
      else
        existing.value = value
        return false
      endIf

    method add_entry( Mapping<<$KeyType,$ValueType>> entry ).Logical:
      local var existing = find_entry( entry.key )
      if (existing is null)
        entries.add( entry )
        return true
      else
        existing.value = entry.value
        return false
      endIf

    method to_String.String:
      local StringBuilder buffer()
      forEach (entry in entries) buffer.print( "[$=$]" (entry.key,entry.value) )
      return buffer.to_String
endClass


class HashTableValueReader<<$KeyType,$ValueType>> : Reader<<$ValueType>>
  # Reader that iterates through a HashTable's values.
  PROPERTIES
    bins    : Reader<<HashTableBin<<$KeyType,$ValueType>>>>
    entries : Reader<<Mapping<<$KeyType,$ValueType>>>>

  METHODS
    method init( bins ):
      if (bins.has_another) 
        entries = bins.read.entries.create_reader
      endIf
      prep_next

    method prep_next:
      # Prepares the next value that will be used by peek() and 
      # read().
      if (entries is null) return
      while (not entries.has_another)
        if (bins.has_another) 
          entries = bins.read.entries.create_reader
        else
          entries = null; return
        endIf
      endWhile

    method has_another.Logical: 
      # Returns "true" if this reader has another value that can
      # be previewed with peek() or read with read().
      return entries isNot null

    method peek.$ValueType:
      # Returns the next value that will be returned from read().
      # If there is no next value then a NoNextValueError is thrown.
      return entries.peek.value

    method read.$ValueType:
      # Returns the next value from this reader.  If (not has_another)
      # then a NoNextValueError is thrown.
      local var result = entries.read.value
      prep_next
      return result

endClass

underlying aspect Set<<$DataType>> : Readable<<$DataType>>
  METHODS
    method add( $DataType value ).Set<<$DataType>>:
      # Adds value to this set and returns the set for call chaining.
      if (not contains(value)) this[value] = value
      return this

    method add( Reader<<$DataType>> reader ).Set<<$DataType>>:
      # Adds all the values from the given reader to this set and returns 
      # this set for call chaining.
      forEach (value in reader) add(value)
      return this

    method remove( Reader<<$DataType>> reader ):
      forEach (key in reader) remove(key)

    method union( Set<<$DataType>> other ):
      # Synonym for add().
      add( other )

    method intersect( Set<<$DataType>> other ):
      # Removes all values in this set that are not in the other set.
      forEach (value in this)
        if (not other.contains(value)) remove(value)
      endForEach

    method create_reader.Reader<<$DataType>>:
      return values

endAspect


class HashSet<<$DataType>> : Set<<$DataType>>, HashTable<<$DataType,$DataType>>
  # Models a set of unique items stored in no particular order.
  # Uses a HashTable. Good for non-comparable items. For DataTypes
  # that may be relatively compared, consider using a TreeSet
  # instead.
endClass


#=====================================================================
# For Old Event System
#=====================================================================
underlying aspect DispatcherType;


#=====================================================================
# Scanner
#=====================================================================
class Scanner
  # Wraps an existing character reader (or readable object) and parses
  # various types of input from it.
  #
  # This is similar to Java's Scanner except it will not skip input
  # looking for tokens but rather throw an error if asked to scan
  # an input that is not immediately available.
  #
  # It is often useful to have a LineReader read in lines from a 
  # file and then use a Scanner to parse each line.
  #
  # Plasmacore Example:
  #   # Say file contains: 
  #   #   width: 800; height:400;
  #
  #   forEach (line in LineReader(DataFile("config.txt")))
  #     local Scanner scanner(line)
  #     while (scanner.next_is_id)
  #       local String name = scanner.scan_id
  #       scanner.must_consume(":")
  #
  #       local Int32 value = scanner.scan_Int32
  #       println( "$ = $" (name,value) )
  #         # prints:
  #         #  width = 800
  #         #  height = 400
  #       scanner.must_consume(";")
  #     endWhile
  #   endForEach
  #
  # Scanner is not intented for use with stdin.  If you want to
  # scan from the keyboard, create a LineReader(System.in) and create
  # a Scanner on each individual line it returns.  For example:
  #
  # forEach (line in LineReader(stdin))
  #   local Scanner scanner(line)
  #   ...
  # endForEach
  PROPERTIES
    src : ParseReader
      # Internal use - the input source for this scanner.

    text_buffer() : StringBuilder
      # Internal use.

    discard_eols = false : Logical
      # Discard EOL characters while discarding whitespace?
      # EOL characters may also be detected and discarded with
      # consume_eol() and consume_eols().

  METHODS
    method init( Reader<<Char>> reader ):
      if (reader is stdin) throw InvalidOperandError( "Can't use stdin directly in class Scanner - see an alternative in the code comments for class Scanner." )
      src = ParseReader(reader)

    method init( ArrayList<<Char>> list ):
      src = ParseReader(list)

    method init( String text ):
      src = ParseReader(text)

    method consume_ws.Logical:
      # Internal use - discards any whitespace that comes next in 
      # the input; called before every scan() and peek() except
      # peek_line() and scan_line().  Returns "true" if any whitespace
      # was consumed.
      #
      # If the "discard_eols" property is "true", then eols
      # are discarded at the same time.
      if (discard_eols)
        if (src.consume(' ') or src.consume('\n'))
          while (src.consume(' ') or src.consume('\n')) noAction
          return true
        else
          return false
        endIf
      else
        if (src.consume(' '))
          while (src.consume(' ')) noAction
          return true
        else
          return false
        endIf
      endIf

    method consume_eol.Logical:
      # Attempts to read and discard a single EOL (\n) from the
      # input.  Returns "true" on success.

      # Must consume_ws on our own to prevent a possible infinite recursion.
      while (src.consume(' ')) noAction
      return src.consume('\n')

    method consume_eols.Logical:
      # Attempts to read and discard one or more EOL characters.  Returns
      # "true" on success.
      while (src.consume(' ')) noAction
      if (src.consume('\n'))
        while (src.consume('\n')) noAction
        return true
      else
        return false
      endIf

    method has_another.Logical: 
      # Returns "true" if scanner reader has another value that can
      # be previewed with peek() or read with read().
      consume_ws
      return src.has_another

    method consume( Char ch ).Logical:   
      # Attempts to read and discard the character ''ch''.  Returns
      # "true" on success.
      consume_ws
      return src.consume( ch )

    method consume( String st ).Logical: 
      # Attempts to read and discard the string 'st'.  Returns
      # "true" on success.
      consume_ws
      return src.consume( st )

    method must_consume( Char ch, String mesg=null ):
      # Throws a NoNextValueError if the character ''ch'' cannot
      # be consumed.
      consume_ws
      if (not consume(ch)) 
        if (mesg is null) mesg = "'$' expected." (ch)
        throw NoNextValueError(mesg)
      endIf

    method must_consume( String st, String mesg=null ):
      # Throws a NoNextValueError if the string 'st' cannot
      # be consumed.
      consume_ws
      if (not consume(st)) 
        if (mesg is null) mesg = "'$' expected." (st)
        throw NoNextValueError(mesg)
      endIf

    method next_is( String st ).Logical:
      # Returns true if the next input matches the given string.
      # consume(String) may be used to read past the string.
      consume_ws
      local var mark = src.save_position
      local var result = src.consume( st )
      src.restore_position(mark)
      return result

    method scan_remaining.String:
      # Returns all remaining characters as a single string.
      # Does not consume leading whitespace.
      local StringBuilder buffer()
      forEach (ch in src) buffer.print(ch)
      return buffer.to_String

    method peek_line.String:
      # Returns the next string that will be returned from 
      # scan_line().  If there is no next value then a
      # NoNextValueError is thrown.  Does not discard leading
      # whitespace like most scan methods.
      local var mark = src.save_position
      local var result = src.read_line
      src.restore_position(mark)
      return result

    method scan_line.String:
      # Returns the next line of input up to a LF or CRLF.  CRLF
      # characters are discarded.  Does not discard leading 
      # whitespace like most scan methods.
      return src.read_line

    method peek_Char.Char:
      # Returns the character that will be returned from the next call
      # to scan_Char().  If there is no next value then a 
      # NoNextValueError is thrown.
      consume_ws
      return src.peek

    method scan_Char.Char: 
      # Returns the next character of input.
      consume_ws
      return src.read

    method next_is_Int32.Logical:
      # Returns "true" if the pending input can be interpreted
      # as an Int32 value.  
      #
      # Note: if the next input were "3.14" then next_is_Int32() 
      # would return "true" and scan_Int32() would return "3"
      #
      # Note: the internal system is currently unable to determine 
      # which integers will fit in an Int32 and which require an Int64; 
      # it is up to the programmer to anticipate this and use the correct 
      # call.
      return next_is_Int64

    method peek_Int32.Int32:
      # Returns the Int32 that will be returned from the next call to
      # scan_Int32().  If there is no next value then a 
      # NoNextValueError is thrown.
      #
      # Note: if the next input were "3.14" then 
      # peek_Int32() would return "3"
      #
      # Note: the internal system is currently unable to determine 
      # which integers will fit in an Int32 and which require an Int64; 
      # it is up to the programmer to anticipate this and use the correct 
      # call.
      return Int32(scan_Int64)

    method scan_Int32.Int32:
      # Attempts to parse and return an Int32 value from the pending
      # input.  Throws a NoNextValueError on failure.
      #
      # Returns the Int32 that will be returned from the next call to
      # scan_Int32().  If there is no next value then a 
      # NoNextValueError is thrown.
      #
      # Note: if the next input were "3.14" then 
      # scan_Int32() would return "3"
      #
      # Note: the internal system is currently unable to determine 
      # which integers will fit in an Int32 and which require an Int64; 
      # it is up to the programmer to anticipate this and use the correct 
      # call.
      return Int32(scan_Int64)

    method next_is_Int64.Logical:
      # Returns "true" if the pending input can be interpreted
      # as an Int64 value.  
      #
      # Note: if the next input were "3.14" then next_is_Int64() 
      # would return "true" and scan_Int64() would return "3"
      #
      # Note: the internal system is currently unable to determine 
      # which integers will fit in an Int32 and which require an Int64; 
      # it is up to the programmer to anticipate this and use the correct 
      # call.
      consume_ws
      if (not src.has_another) return false
      local Char ch = src.peek
      if (ch >= '0' and ch <= '9') return true
      if (ch == '-' or ch == '+')
        ch = src.peek(2)
        return (ch >= '0' and ch <= '9')
      else
        return false
      endIf

    method peek_Int64.Int64:
      # Returns the Int64 that will be returned from the next call to
      # scan_Int64().  If there is no next value then a 
      # NoNextValueError is thrown.
      #
      # Note: if the next input were "3.14" then 
      # peek_Int64() would return "3"
      #
      # Note: the internal system is currently unable to determine 
      # which integers will fit in an Int32 and which require an Int64; 
      # it is up to the programmer to anticipate this and use the correct 
      # call.
      consume_ws
      local var mark = src.save_position
      local var result = scan_Int64
      src.restore_position(mark)
      return result

    method scan_Int64.Int64:
      # Attempts to parse and return an Int64 value from the pending
      # input.  Throws a NoNextValueError on failure.
      #
      # Returns the Int64 that will be returned from the next call to
      # scan_Int64().  If there is no next value then a 
      # NoNextValueError is thrown.
      #
      # Note: if the next input were "3.14" then 
      # scan_Int64() would return "3"
      #
      # Note: the internal system is currently unable to determine 
      # which integers will fit in an Int32 and which require an Int64; 
      # it is up to the programmer to anticipate this and use the correct 
      # call.
      consume_ws

      local Int64 n = 0
      local var is_negative = false
      if (consume('-')) is_negative = true
      else consume('+')

      local var ch = src.read
      if (ch < '0' or ch > '9') throw NoNextValueError()

      n = (ch - '0')
      ch = src.peek
      while (ch >= '0' and ch <= '9')
        n = n * 10 + (src.read - '0')
        ch = src.peek
      endWhile

      if (is_negative) return -n
      return n

    method next_is_Real64.Logical:
      # Returns "true" if the pending input can be interpreted
      # as a Real64 value.
      if (next_is_Int64) return true

      if (not src.has_another) return false

      local var ch = src.peek
      if ((ch == '-' or ch == '+') and src.peek(2) == '.')
        ch = src.peek(3)
        return (ch >= '0' and ch <= '9')
      
      elseIf (ch == '.')
        ch = src.peek(2)
        return (ch >= '0' and ch <= '9')

      else
        return false
      endIf


    method peek_Real64.Real64:
      # Returns the Real64 that will be returned from the next call to
      # scan_Real64().  If there is no next value then a 
      # NoNextValueError is thrown.
      consume_ws
      local var mark = src.save_position
      local var result = scan_Real64
      src.restore_position(mark)
      return result

    method scan_Real64.Real64:
      # Attempts to parse and return a Real64 value from the pending
      # input.  Throws a NoNextValueError on failure.
      local var is_negative = false
      local Real64 n = 0.0
      if (next_is_Int64)
        if (src.consume('-')) is_negative = true
        n = scan_Int64
      else
        local var ch = src.peek
        if (ch == '-') is_negative = true; src.read
        elseIf (ch == '+') src.read
        if (src.peek != '.') throw NoNextValueError()
      endIf

      if (src.consume('.'))
        local var ch = src.peek
        if (ch == '-' or ch == '+') throw NoNextValueError()
        local var zeros = 0
        while (src.consume('0')) ++zeros
        local Real64 fraction = 0.0
        if (src.has_another)
          ch = src.peek
          if (ch >= '0' and ch <= '9') fraction = scan_Int64
        endIf
        while (fraction >= 1) fraction /= 10.0
        while (zeros?) --zeros; fraction /= 10.0
        n += fraction
      endIf

      if (is_negative) return -n
      else return n

    method next_is_String.Logical:
      # Returns "true" if the pending input can be interpreted
      # as a quoted string value of the form:
      #
      #   "...(chars)..." or
      #   '...(chars)...' or
      #
      # The following special characters are interpreted as follows:
      #   \n -> Char(10)
      #   \\ -> \
      #   \" -> "
      #   \' -> '
      #   \x -> x  (where x is any other character)
      local var mark = src.save_position
      local var result = scan_String(false)
      src.restore_position(mark)
      return result?

    method scan_String( Logical fail_on_error=true ).String:
      # Attempts to parse and return a quoted String value from the pending
      # input.  The returned string does not include the surrounding quotes.  
      consume_ws

      if (not src.has_another) 
        if (fail_on_error) throw NoNextValueError()
        return null
      endIf

      local var start_quote = src.peek
      if (start_quote != '"' and start_quote != '\'')
        if (fail_on_error) throw NoNextValueError()
        else return null
      endIf

      local var mark = src.save_position
      text_buffer.clear
      src.read

      if (not src.has_another)
        if (fail_on_error) throw NoNextValueError( "No closing quote on string." )
        else src.restore_position(mark); return null
      endIf

      local var ch = src.read
      while (ch != start_quote) 
        if (ch == '\n' or not src.has_another)
          if (fail_on_error) throw NoNextValueError( "No closing quote on string." )
          else src.restore_position(mark); return null
        endIf
        if (ch == '\\')
          ch = src.read
          if (ch == 'n') ch = 10
        endIf
        text_buffer.print(ch)
        ch = src.read
      endWhile
      return text_buffer.to_String

    method peek_String.String:
      # Returns the String that will be returned from the next call
      # to scan_String().  If there is no next value then a 
      # NoNextValueError is thrown.
      local var mark = src.save_position
      local var result = scan_String
      src.restore_position(mark)
      return result

    method next_is_id.Logical:
      # Returns "true" if the pending input can be interpreted
      # as an id value of the form [A-Za-z_][A-Za-z_0-9]*
      consume_ws
      if (not src.has_another) return false
      which (src.peek)
        case 'A'..'Z', 'a'..'z', '_':
          return true
        others:
          return false
      endWhich

    method scan_id.String:
      # Attempts to parse and return an id value of the form: [A-Za-z_][A-Za-z_0-9]*
      consume_ws
      local var first = true
      loop
        if (src.has_another)
          which (src.peek)
            case 'A'..'Z', 'a'..'z', '_'
              if (first) text_buffer.clear; first = false
              text_buffer.add( src.read )
              nextIteration

            case '0'..'9'
              if (first) throw NoNextValueError()
              text_buffer.add( src.read )
              nextIteration
          endWhich
        endIf
        if (first) throw NoNextValueError()
        return text_buffer.to_String
      endLoop

    method peek_id.String:
      # Returns the id that will be returned from the next call to
      # scan_id().  If there is no next value then a NoNextValueError 
      # is thrown.
      consume_ws
      local var mark = src.save_position
      local var result = scan_id
      src.restore_position(mark)
      return result
endClass


#=====================================================================
#  HeapSort
#=====================================================================
underlying aspect Comparator<<$DataType>>
  METHODS
    method init:
    method a_before_b( $DataType a, $DataType b ).Logical: abstract
endAspect

class CompareFn<<$DataType,$a_before_b_test>> : Comparator<<$DataType>>
  METHODS
    method a_before_b( $DataType a, $DataType b ).Logical:
      return $a_before_b_test
endClass

enum Sort
  CATEGORIES
    ascending, descending
endEnum


singleton class HeapSort<<$DataType>>
  # Performs an in-place HeapSort on the given list.  
  #
  # Example:
  #   local var nums = {2,3,1,5,4}
  #   HeapSort<<Int32>>.sort(nums)
  #   println( nums )  # prints: {1,2,3,4,5}
  #
  # ---- ALGORITHM (ascending order) ---------------------------------
  #
  # For sorting purposes, a "heap" is a complete binary tree where
  # the only guarantee is that each child node has a value less or
  # equal to than its parent.
  #
  # HEAP CREATION
  #
  # The first step in a heap sort is to construct a heap by adding
  # each unsorted number to it.  To do this we put the number in the 
  # next available position in the heap.  We then maintain the heap
  # invariant by switching the node with its parent so long as it's
  # greater than its parent.
  #
  # Example:
  #   Unsorted numbers:
  #
  #     {2,3,1,5,4}
  #
  #
  #
  #   Heap after adding three numbers:
  #
  #         3
  #        / \
  #       2   1
  #
  #   Add the next number, "5":
  #
  #         3
  #        / \
  #       2   1
  #      /
  #     5
  #
  #   Heapify:
  #
  #         3           3           5
  #        / \         / \         / \
  #       2   1  ->   5   1  ->   3   1
  #      /           /           /
  #     5           2           2
  #
  #   Finished heap after all five numbers:
  #   
  #         5
  #        / \
  #       4   1
  #      / \
  #     2   3
  #
  #
  # ORDERING
  #
  # The heap is complete.  The root node contains the highest (and
  # consequently last) value in our sorted list.  So pluck it off
  # to be the end of our list.
  #
  #         -      Ordered list: 5
  #        / \
  #       4   1
  #      / \
  #     2   3
  #
  # Now if we can quickly "fix" the heap, the root node of the
  # repaired heap will be the next-to-last number in the list.
  # Instead of trying to decide which child to move up to the root
  # (etc., etc.), take the LAST leaf of the heap, put it on top,
  # and poke it back down to an appropriate level by recursively
  # swapping it with the higher of its two children until it's
  # greater than both of its children.
  #
  #         3      Ordered list: 5
  #        / \
  #       4   1    ***Last moves to root position - needs fix
  #      / 
  #     2  
  #
  #         4      Ordered list: 5
  #        / \
  #       3   1    ***Push down by recursively swapping with the 
  #      /            greater of its two children - fixed.
  #     2  
  #
  #         3      Ordered list: 4 5
  #        / \
  #       2   1    ***Pluck next number, move last leaf to root,
  #                   push root down - complete step.
  #
  #         2      Ordered list: 3 4 5
  #        /  
  #       1        ***Pluck next number, move last leaf to root,
  #                   push root down - complete step.
  #
  #      ...
  #
  #      Ordered list: 1 2 3 4 5
  #
  # PRACTICAL IMPLEMENTATION
  #
  # Despite how it may seem at first, HeapSort is a very low-cost
  # algorithm.
  #
  # A binary tree can be represented as a linear array where 
  # 'nodes[i]' has children 'nodes[2*i+1]' and 'nodes[2*i+2]' and 
  # parent 'nodes[(i-1)/2]'. 
  #
  # At any point in the sorting process the number of elements
  # in the list and the number of element in the heap sums to the
  # same N.  This means we can use one end of the original array
  # for the list of numbers and the other end for the heap.  If you
  # like, imagine a partition that slides up and back down - the
  # left side is the heap, the right side is the unsorted (and then
  # sorted) numbers.
  #
  # Here's a side-by-side comparison of adding the 4th number during 
  # heap construction in both conceptual and practical formats
  # (the "|" isn't IN the array but shows the division between
  # heap and list):
  #
  #   Heap after adding three numbers:
  #
  #     CONCEPTUAL           PRACTICAL
  #
  #         3                {3 2 1 | 5 4}
  #        / \
  #       2   1
  #
  #     Remaining: {5 4}
  #
  #
  #   Adding the fourth number:
  #
  #     CONCEPTUAL           PRACTICAL
  #
  #         3                {3 2 1 5 | 4}
  #        / \
  #       2   1
  #      /
  #     5
  #
  #     Remaining: {4}
  #
  #
  #   Heapifying:
  #
  #     CONCEPTUAL           PRACTICAL
  #
  #         3                {3 5 1 2 | 4}
  #        / \
  #       5   1
  #      /
  #     2
  #
  #         5                {5 3 1 2 | 4}
  #        / \
  #       3   1
  #      /
  #     2
  #
  #
  # During ordering, pulling the top number off and replacing it
  # with the last leaf of the tree becomes as simple as swapping
  # the numbers at the beginning and end of the heap array before
  # sliding the partition back one.
  #
  #   Finished heap:  {5 4 1 2 3}
  #
  #                    v       v
  #   Order next:     {5 4 1 2 3 |}  - swap first and last
  #
  #                   {3 4 1 2 5 |}  - swapped
  #
  #                   {3 4 1 2 | 5}  - scoot partition down
  #
  #                   {4 3 1 2 | 5}  - repair heap 
  #
  #                    v     v
  #   Order next:     {4 3 1 2 | 5}
  #
  #                   {2 3 1 4 | 5}
  #
  #                   {2 3 1 | 4 5}
  #
  #                   {3 2 1 | 4 5}
  #
  #                       ...
  #
  #                   {| 1 2 3 4 5}  - Finished!
  PROPERTIES
    default_comparator = CompareFn<<$DataType,a < b>>() : Comparator<<$DataType>>

  METHODS
    method sort( $DataType[] list, Sort order ):
      # Call list.sort(Sort.ascending) or list.sort(Sort.descending).
      if (order is Sort.ascending) sort( list, CompareFn<<$DataType, a < b>>() )
      else                         sort( list, CompareFn<<$DataType, a > b>>() )

    method sort( $DataType[] list, 
        Comparator<<$DataType>> comparator=HeapSort<<$DataType>>.default_comparator ):
      # Sorts 'list' in-place using heapsort.
      #
      # If '$DataType' is a class it must define 
      #   $DataType::op<>($DataType).Int32
      # and
      #   $DataType::op==($DataType).Logical
      #
      # If '$DataType' is a compound then 
      # Global::op<>($DataType,$DataType).Int32 must be defined.
      if (comparator is null) comparator = default_comparator

      # heapify
      forEach (index of list)
        local Int32 cur = index
        local Int32 parent = (index - 1) / 2
        while (cur != 0 and not comparator.a_before_b(list[cur],list[parent]))
          list.swap( cur, parent )
          cur = parent
          parent = (parent - 1) / 2
        endWhile
      endForEach

      # sort
      forEach (index in list.count-1 ..> 0)
        list.swap( 0, index )

        # push value at heap top back down
        local Int32 cur = 0
        loop
          local Int32 left_child = cur * 2 + 1
          local Int32 right_child = cur * 2 + 2
          local var cur_value = list[cur]
          if (right_child < index)
            # two children to pick from
            local var left_value = list[left_child]
            local var right_value = list[right_child]
            if (comparator.a_before_b(cur_value,left_value) and not comparator.a_before_b(left_value,right_value))
              list.swap( cur, left_child )
              cur = left_child
            elseIf (comparator.a_before_b(cur_value,right_value))
              list.swap( cur, right_child )
              cur = right_child
            else
              escapeLoop
            endIf
          elseIf (left_child < index and comparator.a_before_b(cur_value,list[left_child]))
            # only the left child is available - also means this
            # is last iteration for pushing
            list.swap( cur, left_child )
            escapeLoop
          else
            escapeLoop
          endIf
        endLoop
      endForEach
        
endClass


#requisite compound SystemMemoryUsage( Int32 num_objects, Int32 runtime_bytes, Int32 system_object_bytes, Int32 resource_bytes )

#{
singleton class SystemMemoryUsageManager
  METHODS
    method to_String( SystemMemoryUsage usage ).String:
      return "$ objects\nruntime: $(4.2)MB\nsysobjs: $(4.2)MB\nresource:$(4.2)MB" ...
          (usage.num_objects,usage.runtime_bytes/1024.0^2,usage.system_object_bytes/1024.0^2,usage.resource_bytes/1024.0^2)
endClass
}#

requisite singleton class System
  # Contains commands relevant to the operating system.
  PROPERTIES
    dummy_int64_array : Array<<Int64>>
      # Force the ETC code to include a type definition for
      # Array<<Int64>>

    fatal_error_called : Logical
      # Internal use - avoids infinite recursion

  METHODS
    method catch_control_c( Logical setting ): native
      # If you pass setting:true the program will not automatically
      # terminate when you press CTRL+C. Instead, an internal flag
      # will be set that you can poll with control_c_pressed().

    method control_c_pressed.Logical: native
      # Returns true if System.catch_control_c was set to "true"
      # and if CTRL+C was pressed. Resets the internal flag afterwards
      # so that if "true" is returned on the first call, subsequent
      # calls return "false" until the key combination is actually
      # pressed again.

    method exit( Int32 error_code=0, String mesg=null ):
      # Alternative name for 'exit_program'.
      exit_program( error_code, mesg )

    method exit_program( Int32 error_code=0, String mesg=null ): native
      # Terminates the program with the given error code and message.

    method stack_trace.String:
      return StackTrace().to_String

    method get( String property_name ).String: native
      # Returns the value of the named system property (environment variable).
      #
      # Example:
      #   println( System["PATH"] )   

    method os.String: native
      # Returns one of:
      #   mac, windows, unix, iphone, wii

    #method os_version.String: native
      # Returns information about the specific version of the OS in use.
      # Not implemented for all OS & version combinations - may return 
      # "unknown".

    method hardware_version.String: native
      # Returns information about the specific hardware this app is running
      # on.  Currently only implemented for iPhone/iPad.

    method language.String: native
      # Returns one of:
      #   english [default],
      #   japanese, german, french, spanish, italian, dutch
      #   (possibly others)

    method ip.String: native
      # Returns the ip address of this computer.

    private method raw_exe_filepath.String: native
      # Internal use - returns the unprocessed executable filepath.

    method force_garbage_collection( Int32 times ):
      # Calls force_garbage_collection() 'times' in a raw.
      forEach (1..times) force_garbage_collection

    method force_garbage_collection: native
      # The default data collection scheme works well in most cases;
      # calling force_garbage_collection() is not necessary and, if
      # used incorrectly, will force fast heap data that would 
      # otherwise be discarded on the next auto-collection into long 
      # term storage.
      #
      # Call it:
      #
      #   - Near the root of your program execution - e.g. NOT under 
      #     two dozen layers of nested calls.
      #
      #   - Infrequently (minutes apart, such as after loading a new level)
      #
      #   - When you know that all references to a large amount of data 
      #     have just been removed and it is important that that memory
      #     be immediately reclaimed.
      #
      # Objects that require cleanup (see RequiresCleanup) also 
      # require two garbage collections to have their memory released,
      # so in some cases you may wish to call 
      # force_garbage_collection() twice in a row.

    method execute( String cmd, Logical wait_for=true ).Process:
      # Launches a system process to run the given command and 
      # returns the exit code from that process.  Throws an
      # UnsupportedOperationError if the execute() command 
      # is not supported by the native layer.
      #
      # Parameters:
      #   cmd
      #     A program to run.  To run a console command 
      #     "del filename" on a windows machine:
      #       System.execute( "cmd /C del filename" )
      #
      #   wait_for
      #     If "true", waits for the created process to return
      #     before returning from the call (by sleeping for 50 ms
      #     at a time).  The Process object may then be used
      #     to obtain the exit code.  
      #
      #     If "false" the call returns immediately if possible, though
      #     some native layer implementations will always block until
      #     the process is completed.
      local Process process(cmd)
      if (wait_for) process.wait_for_exit
      return process
endClass

class Process : RequiresCleanup
  # Slag-side wrapper for a native layer process.
  PROPERTIES
    exit_code : Int32
      # The exit code.  Only valid if is_active is false.

    is_active : Logical

  METHODS
    method init( String cmd ): native
      # Launches a system process to run the given command.  Some
      # native layer implementations do not support asynchronous 
      # execution and will always block until completed.  Other native 
      # layer implementations do not support system processes and
      # will throw an UnsupportedOperationError

    method update: native
      # Updates the information about this process.

    method release: native
      # Releases any resources associated with this process.

    method exit_code.Int32:
      # Returns the exit code from this process.
      #
      # Throws an Error if this process is not yet finished.
      update
      if (is_active) throw Error("Process hasn't finished.")
      return &exit_code

    method wait_for_exit( Int32 sleep_ms=50 ).Int32:
      # Waits for this process to exit and then returns the exit code.
      # 'sleep_ms' specifys the number of milliseconds to wait inbetween
      # checks for process completion [default: 50ms].
      while (is_active) sleep( sleep_ms ); update
      return exit_code

    method clean_up:
      # Internal use.  Calls release().
      release

endClass

class Stopwatch
  # Provides a simple way to time an interval.  As soon as
  # an Stopwatch is created it starts timing.
  #
  # Example:
  #   local Stopwatch timer()
  #   sleep(1500)
  #   println( timer )
  #     # prints: 1.50 seconds
  PROPERTIES
    start_ms = time_ms : Int64
    stop_ms : Int64

  METHODS
    method init( Logical running=true ):
      # If 'running' is true then the stopwatch starts timing immediately.
      if (not running) stop_ms = start_ms

    method restart:
      # Clears and starts the stopwatch.
      start_ms = time_ms
      stop_ms = 0

    method clear:
      # Clears the stopwatch to zero.  It is usually more convenient to 
      # call restart() instead.
      start_ms = time_ms
      stop_ms = start_ms

    method start:
      # Starts the stopwatch without clearing the current elapsed time.
      start_ms = time_ms - elapsed_ms
      stop_ms = 0

    method stop:
      # Stops the stopwatch; the elapsed time since the stopwatch was
      # created or since the last call to start() can be
      # obtained by to_String(), 'elapsed_ms', or 'elapsed_seconds'.
      stop_ms = time_ms

    #method elapsed.Time:
      # Returns the elapsed time.
      #return Time(elapsed_ms)

    method elapsed_ms.Int64:
      # Returns the elapsed number of milliseconds since the
      # stopwatch was created or since the most recent call to start().
      if (stop_ms?) return (stop_ms - start_ms)
      return (time_ms - start_ms)

    method elapsed_seconds.Real64:
      # Returns the elapsed number of seconds since the
      # stopwatch was created or since the most recent call to start().
      return elapsed_ms / 1000.0

    method to_String.String:
      # Returns the string "n.dd seconds" where "n.dd" is the
      # value 'elapsed_seconds'.
      return "$(.2) seconds" (elapsed_seconds)
endClass

singleton class ArrayOf<<$DataType>>
  # Convenience class that creates multi-dimensional arrays.
  #
  # Example:
  #   local Array<<Array<<Int32>>>> grid = ArrayOf<<Int32>>[3,5]
  #   grid[2][4] = 1
  METHODS
    method create( Int32 dim1, Int32 dim2 ).Array<<Array<<$DataType>>>>:
      # Creates a 2D array of arrays.
      local Array<<Array<<$DataType>>>> outer(dim1)
      forEach (index1 in 0..<dim1)
        outer[index1] = Array<<$DataType>>(dim2)
      endForEach
      return outer

    method create( Int32 dim1, Int32 dim2, Int32 dim3 ).Array<<Array<<Array<<$DataType>>>>>>:
      # Creates a 3D array of arrays of arrays.
      local Array<<Array<<Array<<$DataType>>>>>> outer(dim1)
      forEach (index1 in 0..<dim1)
        outer[index1] = create(dim2,dim3)
      endForEach
      return outer

    method get( Int32 dim1, Int32 dim2 ).Array<<Array<<$DataType>>>>:
      # Calls create(dim1,dim2).
      return create( dim1, dim2 )

    method get( Int32 dim1, Int32 dim2, Int32 dim3 ).Array<<Array<<Array<<$DataType>>>>>>:
      # Calls create(dim1,dim2,dim3).
      return create( dim1, dim2, dim3 )
endClass


singleton class ListOf<<$DataType>>
  # Convenience class that creates single lists and multi-dimensional 
  # lists of lists that are initially structured like 1D, 2D or 3D 
  # arrays.
  #
  # Example:
  #   local Int32[][] grid = ListOf<<Int32>>.create(3,5)
  #   grid[2][4] = 1
  #
  #   local Real64[][] eye = ListOf<<Real64>>[5,5]
  #   forEach (i in 0..4) eye[i][i] = 1.0
  #
  #   local String[] names = ListOf<<String>>[20]
  #   println( names.count )  # prints: 20
  #   println( names[0]    )  # prints: null
  METHODS
    method create( Int32 dim1 ).$DataType[]:
      # Creates a list that contains 'dim1' number of "null" or "0" elements.
      local $DataType zero_value
      return $DataType[]( dim1, zero_value )

    method create( Int32 dim1, Int32 dim2 ).$DataType[][]:
      # Creates a 2D list of lists that can be treated as a 2D array.
      local $DataType zero_value
      return $DataType[][]( dim1, $DataType[](dim2,zero_value) )

    method create( Int32 dim1, Int32 dim2, Int32 dim3 ).$DataType[][][]:
      # Creates a 3D list of lists of lists that can be treated as a 3D array.
      local var result = $DataType[][][]( dim1, null )
      forEach (i of result)
        result[i] = create(dim2,dim3)
      endForEach
      return result

    method get( Int32 dim1 ).$DataType[]:
      # Calls create(dim1).
      return create( dim1 )

    method get( Int32 dim1, Int32 dim2 ).$DataType[][]:
      # Calls create(dim1,dim2).
      return create( dim1, dim2 )

    method get( Int32 dim1, Int32 dim2, Int32 dim3 ).$DataType[][][]:
      # Calls create(dim1,dim2,dim3).
      return create( dim1, dim2, dim3 )
endClass


requisite singleton class FileManager
  METHODS
    method path_separator.Char:
      # Returns the path separator (for separating two different paths) appropriate for the current OS.
      #
      # * Windows: ;
      # * Other: :
      which (System.os)
        case "windows": return ';'
        others:         return ':'
      endWhich

    method directory_separator.Char:
      # Returns the directory seperator appropriate for the current OS.
      #
      # * Windows: \
      # * Others:  /
      which (System.os)
        case "windows": return '\\'
        others:         return '/'
      endWhich
endClass

requisite class File : Readable<<Char>>, Writable<<Char>>
  # Represents a potential file in the operating system.  A File
  # object is created with a filepath; a file of that name may or may
  # not exist yet.
  #
  # A file object is both Readable and Writable as an input and
  # output for characters.  It may be used to obtain directory
  # listings and manage files.
  #
  # Class File uses the following terminology:
  # ;filename
  # :The name of a file without any location information.
  #
  # ;path
  # :The directory location where the file is stored.
  #
  # ;filepath
  # :A filename with path information.
  #
  # Examples:
  #
  #   # print every character in a file "test.txt"
  #   forEach (ch in File("test.txt")) print( ch )
  #
  #   class RecursiveDirectoryListing
  #     METHODS
  #       method init:
  #         # Recursively lists files starting in the current directory
  #         list( "." )
  #   
  #       method list( String filepath ):
  #         local File file(filepath)
  #         file.filepath = file.absolute_filepath
  #         println( file.filepath )
  #   
  #         if (file.is_directory)
  #           forEach (entry in file.directory_listing)
  #             list("$/$" (file.filepath,entry))
  #           endForEach
  #         endIf
  #   endClass
  CLASS_PROPERTIES
    relative  = 1 : Int32
      # For use with directory_listing(Int32).

    absolute  = 2 : Int32
      # For use with directory_listing(Int32).

    recursive = 4 : Int32
      # For use with directory_listing(Int32).

    ignore_hidden = 8 : Int32
      # For use with directory_listing(Int32).

  PROPERTIES
    filepath : String
      # The filepath of this file.

  METHODS
    method init( filepath ):
      # Initializes this file object with the given filepath.  No
      # operating system files are actually opened or created yet.

    method init( String _path, String _filename ):
      # Joins together the given path with the given filename.
      init( _path + FileManager.directory_separator + _filename )

    method exists.Logical: native
      # Returns whether or not this file (or directory) already exists 
      # within the operating system.

    method size.Int32:
      # Returns the byte size of this file.  Throws a FileError
      # if the file does not exist.
      local var reader = create_reader
      local var c = reader.remaining
      reader.close
      return c

    method create_reader.Reader<<Char>>:
      # Creates and returns a character reader for this file which
      # opens the corresponding file in the operating system for
      # reading.
      #
      # If the file doesn't exist or if there's some other error
      # then a FileError exception is thrown.
      return FileReader( filepath )

    method create_writer.TextWriter:
      # Creates and returns a character writer for this file which
      # opens the corresponding file in the operating system for
      # writing.
      #
      # If an error occurs then a FileError exception is thrown.
      return FileWriter( filepath )

    method create_appender.TextWriter:
      # Like write() but appends data to the file, if it exists,
      # rather than overwriting it.
      return FileWriter( filepath, true )

    method load.Byte[]:
      # Returns the content of this file as a byte list.  Equivalent
      # to calling to_bytes() on this File.
      return to_bytes

    method save( Byte[] bytes ):
      # Saves the given bytes to this file.
      local var writer = create_writer
      forEach (b in bytes) writer.write(b)
      writer.close

    method save( Char[] chars ):
      # Saves the given characters to this file.
      local var writer = create_writer
      forEach (b in chars) writer.write(b)
      writer.close

    method save( String st ):
      # Saves the given String to this file.
      local var writer = create_writer
      forEach (ch in st) writer.write(ch)
      writer.close

    method is_directory.Logical: native
      # Returns "true" if the path of this file specifies a directory.

    method path.String:
      # Returns the path denoted by this File object.  This may be relative
      # or absolute depending on the string passed into the initializer.
      # At a minimum, the relative path "." will be returned.
      if (this.is_directory) return filepath

      local Int32 i1 = filepath.last_index_of( '/' );
      local Int32 i2 = filepath.last_index_of( '\\' );
      if (i1 == -1 and i2 == -1) return "."
      if (i1 == -1) return filepath.substring(0,i2-1)
      if (i2 == -1) return filepath.substring(0,i1-1)
      if (i1 > i2)
        return filepath.substring(0,i1-1)
      else
        return filepath.substring(0,i2-1)
      endIf

    method absolute_path.String:
      # Returns the absolute path denoted by this File object.
      return File(absolute_filepath).path

    method filename.String:
      # Returns the filename (without path information) denoted by
      # this File.  If this file points to directory an empty string ("")
      # will be returned.
      if (this.is_directory) return ""

      local Int32 i1 = filepath.last_index_of( '/' );
      local Int32 i2 = filepath.last_index_of( '\\' );
      if (i1 == -1 and i2 == -1) return filepath
      if (i1 == -1) return filepath.substring(i2+1)
      if (i2 == -1) return filepath.substring(i1+1)
      if (i1 > i2)
        return filepath.substring(i1+1)
      else
        return filepath.substring(i2+1)
      endIf

    method to_String.String:
      # Returns the original filepath of this File object.
      return filepath

    method absolute_filepath.String: native
      # Returns the absolute filepath (path + file) of this file.
      #
      # Note: if a filepath doesn't exist it will still be fleshed out
      # with the current full path to allow this method to work with
      # non-existent output files that you may wish to create.

    method directory_listing.String[]:
      # Returns a list of filenames and directory names contained 
      # within the directory represented by this File object.  Throws
      # a FileError if this file does not denote a valid directory.
      #
      # Note: the list of entries returned will not contain the
      # current directory "." or the parent directory "..".
      #
      # See also: directory_listing(Int32)
      local String[] list()
      directory_listing(list)
      return list

    method directory_listing( String[] list ): native
      # Internal helper for directory_listing().String[]

    method directory_listing( Int32 flags ).String[]:
      # A directory listing with more control over the results.  Send in
      # the following File flags (e.g. File.relative):
      #
      # ;relative | absolute
      # :Return the relative filename or absolute filepath.
      #
      # ;recursive
      # :Return all subdirectories as well.
      #
      # ;ignore_hidden
      # :Hidden files (starting with ".") are not added to the results or recursed into.
      local var entries = directory_listing
      local var no_hidden = (flags & ignore_hidden)?

      if ((flags & recursive)?)
        local Int32 recursive_flags = recursive
        if (no_hidden) recursive_flags += ignore_hidden
        local String[] work_list( max(entries.count*2,10) )
        forEach (filename in entries)
          if (no_hidden and filename[0] == '.') nextIteration
          work_list.add( filename )
          local File file( filepath + directory_separator + filename )
          if (file.is_directory) 
            local var prefix = filename + directory_separator
            forEach (child in file.directory_listing(recursive_flags))
              work_list.add( prefix + child )
            endForEach
          endIf
        endForEach
        entries.copy_from( work_list )

      elseIf (no_hidden)
        forEach (filename in entries)
          if (filename[0] == '.') removeCurrent filename
        endForEach
      endIf

      if (not (flags & absolute)?) return entries

      local var abs_path = absolute_filepath + directory_separator
      forEach (index of entries)
        entries[index] = abs_path + entries[index]
      endForEach
      return entries

    method extension.String:
      # Returns extension of the filename including the dot.  Returns
      # an empty string if the filename has no extension.
      #
      # Example:
      #
      #   println( File("standard.slag").extension )  # prints: .slag
      #   println( File("standard").extension )       # empty string
      local var dot = filepath.last_index_of('.')
      if (dot == -1) return ""
      return filepath.substring(dot)

    method copy( String new_name ):
      # Makes a copy of this file named ''new_name''.
      local String cmd
      which (System.os)
        case "windows":
          File(new_name).save( File(absolute_filepath).load )
        others:
          cmd = //cp -f "$" "$"// (absolute_filepath,File(new_name).absolute_filepath)
          if (System.execute(cmd).exit_code?) throw FileError( absolute_filepath )
      endWhich

    method rename( String new_name ): native
      # Attempts to rename this file to have the given filename.
      # This File object's name is not changed; you have to
      # manually create a new File() if you want to access the
      # renamed file. Throws a FileError if the operation fails.

    method delete: native
      # Attempts to delete this file or folder from disk.
      # Throws a FileError if the operation fails.

    method recursive_delete:
      # Recursively deletes this File and everything in it if it's a directory.
      # Throws a FileError if any part of the operation fails.
      if (this.is_directory)
        local Logical full_success = false
        while (not full_success)
          full_success = true
          local var some_success = false
          forEach (entry in directory_listing(absolute+recursive))
            try
              File(entry).delete
              some_success = true
            catch (FileError err)
              full_success = false
            endTry
          endForEach

          if (not (full_success or some_success)) throw FileError( "Could not delete all files." )

          # If the delete fails it's because some of the directories weren't empty,
          # but they should all be empty now.  Try again.
        endWhile
      endIf

      this.delete

    method timestamp.Int64: native
      # Returns a timestamp that indicates when a file was last modified
      # in milliseconds since Jan 1, 1970.  Use Date(file.timestamp) to 
      # turn the timestamp into a date.
      #
      # Throws a FileError if the file isn't found.
      #
      # See also:
      # * [[SlagDoc:Date]Date]]

    method newer_than( String other_filepath ).Logical:
      # Returns true if this file is newer than the file at the given ''other_filepath''.
      if (not File(other_filepath).exists) return true
      return timestamp > File(other_filepath).timestamp

    method touch: native
      # Updates the timestamp on this file to the current time.
      # Creates the file if it isn't there already.

    method mkdir
      # Creates a directory at this filepath.

      # Execute twice since the absolute_filepath can leave off the last entry
      # in a series of non-existing directories.
      forEach (1..2)
        if (File(absolute_filepath).exists) return

        local String cmd
        if (System.os == "android")
          native_mkdir
        else
          if (System.os == "windows")
            cmd = //cmd /C mkdir "$"// (absolute_filepath)
          else
            cmd = //mkdir -p "$"// (absolute_filepath)
          endIf

          if (System.execute(cmd).exit_code?) throw FileError( absolute_filepath )
        endIf
      endForEach

    method native_mkdir: native

    method change_dir: native
      # Sets the current working directory to the one specified by this file.

    method with_os_slashes.File:
      # On Windows, returns a File whose filepath contains only
      # backslashes ('\').  On Mac and Unix the filepath contains
      # only forward slashes.
      if (System.os == "windows") return with_back_slashes
      else return with_forward_slashes

    method with_forward_slashes.File:
      # Returns a new File with any back slashes in the fileptah (\) 
      # converted to forward slashes (/).
      return File( filepath.replace('\\','/') )

    method with_back_slashes.File:
      # Returns a new File with any forward slashes in the fileptah (/) 
      # converted to forward slashes (\).
      return File( filepath.replace('/','\\') )
endClass


requisite class FileReader : Reader<<Char>>, RequiresCleanup
  # Reads one character at a time from a file.

  PROPERTIES
    native_data : NativeData
      # Internal use.

  METHODS
    method init( String filename ): native
      # Opens the given file and preps this reader to read it.
      #
      # If the file doesn't exist or if there are other problems then
      # a FileError will be thrown.

    method close: native
      # Closes this file; no more data may be read from this reader.

    method has_another.Logical: native
      # Returns "true" if this reader has another value that can
      # be previewed with peek() or read with read().

    method peek.Char: native
      # Returns the next value that will be returned from read().
      # If there is no next value then a NoNextValueError is thrown.

    method read.Char: native
      # Returns the next character from the associated file.  If there
      # is no next character than a NoNextValueError is thrown.  Once
      # the last character is read the file is automatically closed.

    method read( Byte[] buffer, Int32 num ).Int32:
      # Reads up to 'num' more characters from the given file and
      # adds them to the given byte list.  Returns the number of
      # characters actually read (0 <= result <= num).
      if (buffer instanceOf ArrayList<<Byte>>)
        buffer.ensure_capacity( buffer.count + num )
        local var num_read = read( buffer.(ArrayList<<Byte>>).data, buffer.count, num )
        buffer.ensure_count( buffer.count + num_read )
        return num_read
      else
        local Array<<Byte>> data(num)
        local var num_read = read( data, 0, num )
        forEach (i of data) buffer.add(data[i])
        return num_read
      endIf

    method read( Array<<Byte>> buffer, Int32 i, Int32 num ).Int32: native
      # Reads up to 'num' more characters from the given file and
      # adds them to the given Byte array starting at index 'i'.  
      # Returns the number of characters actually read such that 
      # 0 <= result <= num.

    method read( Array<<Char>> buffer, Int32 i, Int32 num ).Int32: native
      # Reads up to 'num' more characters from the given file and
      # adds them to the given Char array starting at index 'i'.  
      # Returns the number of characters actually read such that 
      # 0 <= result <= num.

    method available.Int32:
      # Returns the remaining number of characters in this file
      # (same as remaining() in this case).
      return remaining

    method remaining.Int32: native
      # Returns the remaining number of characters in this file.

    method skip( Int32 skip_count=1 ): native
      # Skips over the next 'skip_count' number of characters in
      # this file.  The skip count must be non-negative.

    method position.Int32:  native
      # Returns the position of this file - equivalent to the
      # number of characters read so far.

    method position( Int32 new_position ):
      # Sets this position of this file.  File readers can only be
      # repositioned further on in the file, so new_position must
      # be >= position.
      local var delta = new_position - position;
      if (delta < 0) throw InvalidOperandError("delta","$"(delta))
      if (delta == 0) return
      skip( delta-1 )
      read

    method to_bytes.Byte[]:
      local Array<<Byte>> bytes(remaining)
      read( bytes, 0, remaining )
      return Byte[](bytes,false)

    method to_List.Char[]:
      local Array<<Char>> chars(remaining)
      read( chars, 0, remaining )
      return Char[](chars,false)

    method to_String.String:
      return String.create_from(to_List)

    method clean_up: 
      # Called when there are no more references to this object;
      # closes the file.
      close
      insertUnderlying

endClass


requisite class FileWriter : TextWriter, RequiresCleanup
  # Subclass of TextWriter that prints to a file.  Created
  # by a call to File::create_writer.
  PROPERTIES
    native_data : NativeData
      # Internal use.

  METHODS
    method init( String filename, Logical append=false ): native
      # Initializes this writer to write to the specified file.
      # The file is opened for writing; close() should be called
      # when finished.
      #
      # If there's an error opening the file then a FileError() is
      # thrown.

    method close: native
      # Closes the file.  This should be called after all desired 
      # data has been written to the file.

    method write( Char value ): native
      # Writes 'value' in 8 bits.

    method write( Array<<Char>> buffer, Int32 i, Int32 count ): native
      # Writes a block of 'count' characters to the file starting at index
      # 'i' in the 'buffer'.

    method write( Array<<Byte>> buffer, Int32 i, Int32 count ): native
      # Writes a block of 'count' bytes to the file starting at index
      # 'i' in the 'buffer'.

    method write( String value ): native
      # Writes each of the characters in 'String' as a byte.

    method print( String value ):
      # Overrides the base definition with a more efficient call to write(String).
      write( value )

    method write( Char[] values )
      # Writes all of the characters in 'values' to the file.
      write( values.data, 0, values.count )

    method write( Byte[] values )
      # Writes all of the bytes in 'values' to the file.
      write( values.data, 0, values.count )

    method position.Int32: native
      # This property-read returns the position of the file, 
      # equivalent to the number of characters that have been written
      # thus far.

    method holds_another.Logical:
      # Returns "true".
      return true

    method clean_up: 
      # Called when there are no more references to this object;
      # closes the file.
      close
      insertUnderlying
endClass

augment String
  METHODS
    method to_File.File:
      # Returns a File object with this string as the filepath.
      return File(this)
endAugment

augment System
  METHODS
    method exe_filepath.String:
      # Returns the absolute path and filename of the executable.
      #
      # Example:
      #   println( System.exe_filepath )  # might print:  c:\Program Files\Slag\slag.exe
      local var base_name = raw_exe_filepath
      if (os == "windows" and not base_name.to_lowercase.ends_with(".exe"))
        base_name += ".exe"
      endIf

      if (File(base_name).filename != base_name) return File(base_name).absolute_filepath

      base_name = FileManager.directory_separator + base_name
      local var dir_separator = FileManager.directory_separator
      forEach (search_path in this["PATH"].split(FileManager.path_separator))
        local File file( search_path + base_name )
        if (file.exists and not file.is_directory) return file.absolute_filepath
      endForEach

      return base_name.substring(1)

endAugment


#==============================================================================
# Task
# TaskFn
# TaskManager
#==============================================================================

class Task
  # Provides thread-like behavior for single-threaded Slag programs.  Extended 
  # Task objects have their update() continuously called; each should perform 
  # an incremental amount of work appropriate to 1/60th of a second and then 
  # return.
  #
  # Overview:
  #
  #   1.  Create any number of extended Task objects.
  #
  #   2.  In your program's main function, either continuously call 
  #       TaskManager.update() or call TaskManager.run(), which continuously
  #       calls update() and blocks until all tasks have exited or the end of 
  #       the program has been reached.
  #
  #       NOTE: this part is done for you if you're using Plasmacore.
  #
  #   3.  Call Task::exit() to terminate a task.
  PROPERTIES
    task_active = true : Logical

  METHODS
    method update:
      # Override this method with custom update code.

    method exit:
      # Terminates this task.
      task_active = false

    method init
      # Default initializer; override if desired.

    method init_object:
      TaskManager.add(this)
endClass

class TaskFn<<$update_code>> : Task
  method update: $update_code
endClass

singleton class TaskManager
  # Manages active tasks.  Call TaskManager.update() to update any tasks that
  # require it, or call TaskManager.run() to continuously update all tasks
  # until they've all finished or until the program exits.

  PROPERTIES
    tasks         : Task[]
    active_list   : Task[]

  METHODS
    method init
      if (tasks is null)
        # Safe for all orders of initialization
        tasks = Task[]()
        active_list = Task[]()
      endIf

    method add( Task task )
      init  # Order of initialization safety
      tasks.add( task )

    method update:
      # Updates all tasks.
      if (tasks.count == 0) return

      forEach (task in active_list.transfer_from(tasks))
        if (task.task_active)
          task.update
          tasks.add(task)
        endIf
      endForEach

    method run:
      # Continuously updates all tasks until all tasks have exited or the
      # program ends.
      while (tasks.count?)
        sleep(1000/60)
        update
      endWhile
endClass

underlying aspect UniqueHash
  PROPERTIES
    hash_code=unique_Int32 : Int32

  METHODS
    method hash_code.Int32:
      return &hash_code
endAspect


#=====================================================================
# SignalManager
#=====================================================================
requisite singleton class SignalManager
  PROPERTIES
    signal_handlers(64) : ReferenceTable<<String,SignalHandler>>

    pending_signals(20) : Signal[]
      # Master list of pending events.

    native_signals(20)  : Signal[]
      # Suitable for use by one concurrent native thread at a time.

    active_signals(20)  : Signal[]
      # Currently being iterated through.

  METHODS
    method init
      install_default_signal_handlers

    requisite method find_signal_id( String id ).String
      # Signal id strings are ideally compared with 'is' instead of '=='.
      # This method converts an '==' equals string into an 'is' equals
      # string if possible.
      return signal_handlers.find_key(id)

    requisite method queue( Signal s )
      # Call from any Slag code to queue up the given signal for
      # dispatch later.
      pending_signals.add( s )

    requisite method queue_native( Signal s )
      # Should be called only by the native layer in order to remain
      # thread safe.
      native_signals.add( s )

    requisite method queue_native( String signal_id, Object argument )
      # Should be called only by the native layer in order to remain
      # thread safe.
      native_signals.add( Signal(signal_id,argument) )

    method raise( Signal signal )
      # Immediately dispatches signal 'signal' to all handlers.
      local var signal_id = signal.id
      local var handler = signal_handlers[signal_id]
      if (handler?) 
        # Dispatch signal
        local var new_handler = handler.handle(signal)

        # Adjust handler table if handler has removed itself.
        if (new_handler isNot handler)
          if (new_handler?) signal_handlers[signal_id] = new_handler
          else signal_handlers.remove( signal_id )
        endIf
[if defined(PLASMACORE)]
      else
        log( "Unhandled signal: " + signal_id )
[endIf]
      endIf

    requisite method raise_pending.Logical
      # Should only be called from the native layer to allow
      # garbage collection between signals.
      pending_signals.add( native_signals )
      native_signals.clear

      if (pending_signals.count?)
        forEach (signal in active_signals.transfer_from(pending_signals))
          raise( signal )
        endForEach

        return true

      else
        return false
      endIf

    method install_default_signal_handlers
      SignalHandler("launch") with
        method on( Signal s )
          local var main_object = s.argument
          main_object.init_object
          main_object.init
      endWith

endClass

requisite class Signal
  PROPERTIES
    id       : String
    argument : Object

  METHODS
    requisite method init( id, argument=null )

    method raise
      # Immediately dispatches this signal.
      SignalManager.raise( this )

    method queue
      # Queues up this signal for dispatch after the current signal 
      # handler (update/draw/etc.) has finished.
      SignalManager.queue( this )
endClass

requisite class SignalObjectArg : Signal
  PROPERTIES
    object : Object
    x, y   : Real64

  METHODS
    requisite method init( object )
    requisite method init( object, x, y )
endClass

requisite class SignalDataArg
  PROPERTIES
    id, index : Int32
    flag      : Logical
    x, y      : Real64

  METHODS
    requisite method init( id, index, flag, x, y )
endClass

aspect SignalListener
  METHODS
    method on( Signal signal )
endAspect

class SignalHandler
  # Override extended classes of SignalHandler to handle specific native events.
  # For instance, this code prints trace messages on suspend, resume, and draw:
  # 
  #   SignalHandler("suspend") with
  #     method on( Signal e ): println("APP SUSPENDED")
  #   endWith
  #
  #   SignalHandler("resume") with
  #     method on( Signal e ): println( "APP RESUMED" )
  #   endWith
  #
  #   SignalHandler("draw",SignalHandler.append) with
  #     method on( Signal e )
  #       println( "After main draw" )
  #   endWith 
  #
  # A signal handler is automatically installed when you instantiate it.
  # Send SignalHandler.insert/append/exclusive as the second argument
  # (default 'insert').  Optionally send an object that incorporates the
  # SignalListener interface as the third argument and its on(Signal)
  # method will be called every time the signal fires.  Signal listeners 
  # (as the third parameter, not Signal Handlers in general) are
  # stored with a weak reference so as not to prevent the target object
  # from being reclaimed.
  ENUMERATE
    insert, append, exclusive, pending_deactivate

  PROPERTIES
    event_id     : String
    next_handler : SignalHandler
    listener     : Weak<<SignalListener>>
    callback     : Delegate()
    order        : Int32

  METHODS
    method init( event_id, order=insert )
      if (SignalManager.signal_handlers.contains(event_id))
        next_handler = SignalManager.signal_handlers[event_id]
      endIf
      SignalManager.signal_handlers[event_id] = this

    method init( event_id, order=insert, SignalListener _listener )
      if (_listener?) listener = Weak<<SignalListener>>(_listener)

    method init( event_id, SignalListener _listener )
      init( event_id, insert, _listener )

    method init( event_id, order, callback )
      init( event_id, order )

    method init( event_id, callback )
      init( event_id, insert )

    method deactivate
      order = pending_deactivate

    method on( Signal signal )
      # Override this unless you've supplied a signal listener. 
      if (listener?)
        if (listener.object?) listener.object.on( signal )
        else listener = null
      elseIf (callback?)
        callback.call
      else
        println( //on(Signal) not defined in "$" signal handler.// (event_id) )
      endIf

    method handle( Signal signal ).SignalHandler
      if (order == pending_deactivate)
        if (next_handler?) return next_handler.handle( signal )
        else               return null
      else
        which (order)
          case insert
            on( signal )
            if (next_handler?) next_handler .= handle( signal )

          case append
            if (next_handler?) next_handler .= handle( signal )
            on( signal )

          case exclusive
            on( signal )
        endWhich
        return this
      endIf

    requisite method delegate_dummy
      # Cross-compile kludge, ignore
      delegate(delegate_dummy)
endClass

requisite underlying aspect DataListener
  METHODS
    requisite method on( Byte[] data )
endAspect

class ReferenceTable<<$KeyType,$ValueType>>
  # Behaves like a HashTable but does an 'is' test first before trying a
  # '==' test and uses closed hashing.  Designed for speed.  Keeps the 
  # table <= 50% full.
  PROPERTIES
    entries    : Array<<Mapping<<$KeyType,$ValueType>>>>
    open_spots : Int32

  METHODS
    method init( Int32 capacity ):
      entries = Array<<Mapping<<$KeyType,$ValueType>>>>(capacity)
      open_spots = capacity / 2

    method set( $KeyType key, $ValueType value ):
      local var limit = entries.count
      local var highest = limit - 1
      local var i = key.hash_code & highest
      loop
        local var entry = entries[i]
        if (entry?)
          if (entry.key == key)
            entry.value = value
            return
          endIf
        else
          entries[i] = Mapping<<$KeyType,$ValueType>>( key, value )
          --open_spots
          if (open_spots == 0)
            local ReferenceTable<<$KeyType,$ValueType>> new_table( limit*2 )
            forEach (index in 0..highest)
              entry = entries[index]
              if (entry?) new_table[entry.key] = entry.value
            endForEach
            entries = new_table.entries
            open_spots = new_table.open_spots
          endIf
          return
        endIf
        i = (i + 1) & highest
      endLoop

    method get( $KeyType key ).$ValueType:
      local var highest = entries.count - 1
      local var first_i = key.hash_code & highest

      # Try faster 'is' test first (will probably work)
      local var i = first_i
      loop
        local var entry = entries[i]
        if (entry?)
          if (entry.key is key)
            return entry.value
          endIf
        else
          escapeLoop
        endIf
        i = (i + 1) & highest
      endLoop

      # Fall back to '==' test.
      i = first_i
      loop
        local var entry = entries[i]
        if (entry?)
          if (entry.key == key)
            return entry.value
          endIf
        else
          return null
        endIf
        i = (i + 1) & highest
      endLoop

    method contains( $KeyType key ).Logical:
      return get(key)?

    method find_key( $KeyType key ).$KeyType:
      # Use an '==' to find the actual key object suitable for an 'is' comparison.
      local var highest = entries.count - 1
      local var i = key.hash_code & highest

      loop
        local var entry = entries[i]
        if (entry?)
          if (entry.key == key)
            return entry.key
          endIf
        else
          return null
        endIf
        i = (i + 1) & highest
      endLoop

    method remove( $KeyType key ).$ValueType:
      local var highest = entries.count - 1
      local var i = key.hash_code & highest

      loop
        local var entry = entries[i]
        if (entry?)
          if (entry.key == key)
            entries[i] = null
            ++open_spots
            return entry.value
          endIf
        else
          return null
        endIf
        i = (i + 1) & highest
      endLoop

endClass


class GlobalUpdate : SignalHandler
  METHODS
    method init_object
      SignalHandler( GlobalUpdate target=this ) with
        method init_object
          prior.init( "update" )

    method on( Signal e )
          target.update
      endWith

    method update
      println( type_name + " update" )
endClass


requisite aspect StringIDAccess;


#==============================================================================
# Event System
#==============================================================================
#{
class EventMapping : Mapping<<Weak<<Object>>,Object>>;

class EventMap
  # Similar to a HashTable, an EventMap:
  # - Uses closed hashing in a single array.
  # - Keeps weak references to key objects and uses the 'is' test on keys
  #   versus the weak reference contents.
  # - Keeps the table <= 50% full, expanding as necessary.
  PROPERTIES
    entries    : Array<<EventMapping>>
    open_spots : Int32
    mod_mask   : Int32

  METHODS
    method init( Int32 capacity=16 )
      # Ensure capacity is a power of 2
      local var pow2 = 1
      while (pow2 < capacity) pow2 = pow2.left_shifted(1)
      capacity = pow2
      mod_mask = capacity - 1

      entries = Array<<EventMapping>>( capacity )
      open_spots = capacity / 2

    method set( Object key, Object value )
      local var i = key.hash_code & mod_mask
      loop
        local var entry = entries[i]
        if (entry?)
          # Replace existing dead key or same key
          local var entry_key = entry.key.object
          if (entry_key is null)
            entry.key = Weak<<Object>>( key )
            entry.value = value
            return
          elseIf (entry_key is key)
            entry.value = value
            return
          endIf
        else
          # Found an open spot
          entries[i] = EventMapping( Weak<<Object>>(key), value )
          --open_spots
          if (open_spots == 0)
            local EventMap new_table( entries.count*2 )
            forEach (index of entries)
              entry = entries[index]
              if (entry?)
                local var entry_key = entry.key.object
                if (entry_key?)
                  new_table[entry_key] = entry.value
                endIf
              endIf
            endForEach
            entries = new_table.entries
            open_spots = new_table.open_spots
          endIf
          return
        endIf
        i = (i + 1) & mod_mask
      endLoop

    method get( Object key ).Object
      local var i = key.hash_code & mod_mask

      loop
        local var entry = entries[i]
        if (entry?)
          if (entry.key.object is key)
            return entry.value
          endIf
        else
          return null
        endIf
        i = (i + 1) & mod_mask
      endLoop

    method contains( Object key ).Logical
      return get(key)?

    method remove( Object key ).Object
      local var i = key.hash_code & mod_mask

      loop
        local var entry = entries[i]
        if (entry?)
          if (entry.key.object == key)
            entries[i] = null
            ++open_spots
            return entry.value
          endIf
        else
          return null
        endIf
        i = (i + 1) & mod_mask
      endLoop

    method remove_value( Object value )
      # Necessary to remove bindings whose key object have gone null.
      forEach (index of entries)
        local var entry = entries[index]
        if (entry? and entry.value is value)
          entries[index] = null
          return
        endIf
      endForEach

endClass

requisite singleton class EventManager<<$EventType>>
  PROPERTIES
    global     : EventBinding<<$EventType>>
    bindings() : EventMap

  METHODS
    method add_listener( EventListener<<$EventType>> listener, Object parent,
        Int32 flags=0 )

      if (flags == 0) flags = $EventType.default_flags

      if (parent?)
        local var cur = bindings[parent] coerceAs EventBinding<<$EventType>>
        if (cur?)
          while (cur.next?) cur .= next
          cur.next = EventBinding<<$EventType>>( listener, flags )
        else
          bindings[parent] = EventBinding<<$EventType>>( listener, flags )
        endIf
      else
        if (global?)
          local var cur = global
          while (cur.next?) cur .= next
          cur.next = EventBinding<<$EventType>>( listener, flags )
        else
          global = EventBinding<<$EventType>>( listener, flags )
        endIf
      endIf

    method insert_listener( EventListener<<$EventType>> listener, 
        Object parent, Int32 flags=0 )

      if (flags == 0) flags = $EventType.default_flags

      if (parent?)
        local var parent_binding = bindings[parent] coerceAs EventBinding<<$EventType>>
        if (parent_binding?)
          local EventBinding<<$EventType>> binding( listener, flags )
          binding.next = parent_binding
          bindings[parent] = binding
        else
          bindings[parent] = EventBinding<<$EventType>>( listener, flags )
        endIf
      else
        local EventBinding<<$EventType>> binding( listener, flags )
        binding.next = global
        global = binding
      endIf

    method dispatch( $EventType event, Object origin )
      if (origin is null)
        if (global?) global = dispatch( event, global, null )
      else
        # Specific origin
        local var binding = bindings[origin] coerceAs EventBinding<<$EventType>>
        if (binding?)
          local var result = dispatch( event, binding, origin )
          if (result isNot binding)
            if (result?) bindings[origin] = result
            else         bindings.remove(origin)
          endIf
        endIf
      endIf

    method dispatch( $EventType event, EventBinding<<$EventType>> binding, Object origin ) ...
        .EventBinding<<$EventType>>

      if ((binding.flags & Event.locked)?)
        println( "Cyclical event listener dependency for type " + event.type_name )
        binding.flags &= !Event.locked
        return binding
      endIf

      local var listener = binding.listener.object
      if (listener is null)
        # Dead reference to GC'd object
        bindings.remove_value( binding )
        if (binding.next?) return dispatch( event, binding.next, origin )
        else               return null
      endIf

      binding.flags |= Event.locked

      if ((binding.flags & Event.on_enter)?)
        event.state |=  on_enter
        event.state &= !on_leave
        listener.on( event )
      endIf

      if ((event.state & Event.inactive) == 0)
        # Dispatch to child listeners of the current listener,
        # skipping recursive calls to any objects listening
        # to themselves.
        if (listener isNot origin)
          local var child_binding = bindings[listener] coerceAs EventBinding<<$EventType>>
          if (child_binding?)
            local var result = dispatch( event, child_binding, listener )
            if (result isNot child_binding)
              if (result?) bindings[listener] = result
              else         bindings.remove(listener)
            endIf
          endIf
        endIf
      else
        event.state &= !Event.suppressed
      endIf

      if ((event.state & Event.canceled) == 0)
        if ((binding.flags & Event.on_leave)?)
          event.state |=  on_leave
          event.state &= !on_enter
          listener.on( event )
        endIf

        if (binding.next?)
          binding.next = dispatch( event, binding.next, origin )
        endIf
      endIf

      binding.flags &= !Event.locked

      return binding
endClass

class EventBinding<<$EventType>>
  PROPERTIES
    listener : Weak<<EventListener<<$EventType>>>>
    next     : EventBinding<<$EventType>>
    flags    : Int32

  METHODS
    method init( EventListener<<$EventType>> listener_object, flags )
      listener = Weak<<EventListener<<$EventType>>>>( listener_object )
endClass

aspect EventListener<<$EventType>>
  underlying method on( $EventType e )
endAspect

class Event
  ENUMERATE
    on_enter   = 0b00000001
    on_leave   = 0b00000010
    on_both    = 0b00000011

    suppressed = 0b00000100
    canceled   = 0b00001000
    inactive   = 0b00001100

    locked     = 0b00010000

  PROPERTIES
    state : Int32

  METHODS
    method dispatch( Object parent )
      noAction  # overridden

    method dispatch
      # Global dispatch
      dispatch( null.(Object) )

    method entering.Logical
      return (state & on_enter)?

    method leaving.Logical
      return (state & on_leave)?

    method suppress
      state |= suppressed

    method cancel
      state |= canceled

endClass

class CustomEvent<<$EventType,$flags>> : Event
  PROPERTIES
    source : Object

  CLASS_METHODS
    method default_flags.Int32
      return $flags

    method add_listener( Object listener, Object parent=null )
      EventManager<<$EventType>>.add_listener( 
          listener.(EventListener<<$EventType>>), parent )

    method insert_listener( Object listener, Object parent=null )
      EventManager<<$EventType>>.insert_listener( 
          listener.(EventListener<<$EventType>>), parent )

  METHODS
    method init( source )

    method dispatch( Object parent )
      EventManager<<$EventType>>.dispatch( this.($EventType), parent )
endClass
}#

#==============================================================================
# PropertyTable
#==============================================================================
class PropertyData( String data )
  # Manages a set of property values encoded as a String (akin
  # to JSON format).  You can add PropertyData to a PropertyTable
  # or PropertyList directly or you can parse() it into a
  # PropertyValue (typically a PropertyTable or PropertyList).
  CLASS_METHODS
    method parse_value( ParseReader reader ).PropertyValue
      while (reader.consume(' ')) noAction
      which (reader.peek)
        case '{': return PropertyTable(reader)
        case '[': return PropertyList(reader)
        case '"': return StringProperty(reader)
        case '0'..'9','-': return NumberProperty(reader)
        case 't': reader.must_consume("true");  return TrueProperty
        case 'f': reader.must_consume("false"); return FalseProperty
        case 'n': reader.must_consume("null");  return NullProperty
        case 'I': reader.must_consume("Infinity"); return NumberProperty(infinity)
        case 'N': reader.must_consume("NaN");      return NumberProperty(NaN)
        others:   
          throw Error( "Unrecognized PropertyData notation: Char($)" (Int32(reader.peek)) )
      endWhich

    method load( File file ).PropertyValue
      return parse_value( ParseReader(String.create_from(file.load)) )

  METHODS
    method parse.PropertyValue
      return parse_value( ParseReader(data) )

endClass

class PropertyValue : StringIDAccess, Readable<<PropertyValue>>
  # Base class for anything that can be in a PropertyTable or
  # PropertyList.
  METHODS
    method count.Int32
      return 0

    method keys.Reader<<String>>
      return String[](0).create_reader

    method create_reader.Reader<<PropertyValue>>
      return PropertyValue[](0).create_reader

    method is_String.Logical
      return false

    method is_number.Logical
      return false

    method as_String.String
      return to_String

    method as_Real64.Real64
      return to_String.to_Real64

    method as_Real32.Real32
      return Real32(as_Real64)

    method as_Int64.Int64
      return Int64(as_Real64)

    method as_Int32.Int64
      return Int32( as_Int64 )

    method as_Char.Char
      return Char( as_Int32 )

    method as_Byte.Byte
      return Byte( as_Int32 )

    method as_Logical.Logical
      return Logical( as_Int32 )

    method op+( PropertyValue other ).PropertyValue
      return StringProperty(as_String + other.as_String)

    method op+( String other ).PropertyValue
      return StringProperty(as_String + other)

    method op+( Real64 other ).PropertyValue
      return StringProperty(as_String + other)

    method op-( PropertyValue other ).PropertyValue
      return NumberProperty( as_Real64 - other.as_Real64 )

    method op-( Real64 other ).PropertyValue
      return NumberProperty( as_Real64 - other.as_Real64 )

    method op*( PropertyValue other ).PropertyValue
      return NumberProperty( as_Real64 * other.as_Real64 )

    method op*( Real64 other ).PropertyValue
      return NumberProperty( as_Real64 * other.as_Real64 )

    method op/( PropertyValue other ).PropertyValue
      return NumberProperty( as_Real64 / other.as_Real64 )

    method op/( Real64 other ).PropertyValue
      return NumberProperty( as_Real64 / other.as_Real64 )

    method to_String.String
      local StringBuilder buffer()
      to_String( buffer, false )
      return buffer.to_String

    method to_String( StringBuilder buffer, Logical strict_json ): abstract

    method to_json.String
      local StringBuilder buffer()
      to_String( buffer, true )
      return buffer.to_String

    method set( String id, PropertyValue value )
      throw UnsupportedMethodError()

    method set( String id, String value )
      throw UnsupportedMethodError()

    method set( String id, Real64 value )
      throw UnsupportedMethodError()

    method set( String id, Logical value )
      if (value) set( TrueProperty )
      else       set( FalseProperty )

    method set( String id, PropertyData value )
      throw UnsupportedMethodError()

    method set( Int32 index, PropertyValue value )
      throw UnsupportedMethodError()

    method set( Int32 index, PropertyData value )
      throw UnsupportedMethodError()

    method set( Int32 index, String value )
      throw UnsupportedMethodError()

    method set( Int32 index, Real64 value )
      throw UnsupportedMethodError()

    method add( PropertyValue value ).PropertyList
      throw UnsupportedMethodError()

    method add( String value ).PropertyList
      throw UnsupportedMethodError()

    method add( Real64 value ).PropertyList
      throw UnsupportedMethodError()

    method add( PropertyData value ).PropertyList
      throw UnsupportedMethodError()

    method get( String id ).PropertyValue
      return null

    method get( Int32 index ).PropertyValue
      return null

endClass

class PropertyTable : PropertyValue
  PROPERTIES
    _internal_property_map() : HashTable<<String,PropertyValue>>
    _internal_file           : File

  METHODS
    method init

    method init( _internal_file )
      if (_internal_file?) load( _internal_file )

    method init( String data )
      init( PropertyData(data) )

    method init( PropertyData data )
      init( ParseReader(data.data) )

    method init( ParseReader reader )
      reader.consume_ws
      reader.must_consume('{')

      reader.consume_ws
      if (not reader.consume('}'))

        local var first = true
        while (first or (not first and reader.consume(',')))
          first = false
        
          local String property_name
          reader.consume_ws
          if (reader.peek == '"')
            property_name = StringProperty(reader).value
          else
            # scan id
            local StringBuilder buffer()
            local var ch = reader.read
            if (not ch.is_letter and ch != '_') throw Error( "Letter or underscore expected." )
            buffer.print(ch)
            ch = reader.peek
            while (ch.is_alphanumeric or ch == '_')
              buffer.print(reader.read)
              ch = reader.peek
            endWhile
            property_name = buffer.to_String
          endIf

          reader.consume_ws
          if (reader.consume(':'))
            reader.consume_ws
            local var value = PropertyData.parse_value(reader)

            set( property_name, value )
          else
            set( property_name, TrueProperty )
          endIf

          reader.consume_ws
        endWhile

        reader.must_consume('}')
      endIf

    method count.Int32
      return _internal_property_map.count

    method keys.Reader<<String>>
      return _internal_property_map.keys

    method create_reader.Reader<<PropertyValue>>
      return _internal_property_map.values

    method load( _internal_file ).Logical
      _internal_property_map = HashTable<<String,PropertyValue>>()
      if (_internal_file? and _internal_file.exists)
        init( String(_internal_file.load) )
        return true
      else
        return false
      endIf

    method save( File save_file=null )
      if (save_file?) _internal_file = save_file
      save_file.save( to_String )

    method set( String id, PropertyValue value )
      if (value?)
        _internal_property_map[ id ] = value
      elseIf (_internal_property_map.contains(id))
        _internal_property_map.remove( id )
      endIf

    method set( String id, String value )
      if (value?)
        _internal_property_map[ id ] = StringProperty( value )
      elseIf (_internal_property_map.contains(id))
        _internal_property_map.remove( id )
      endIf

    method set( String id, Real64 value )
      _internal_property_map[ id ] = NumberProperty( value )

    method set( String id, PropertyData value )
      if (value?)
        _internal_property_map[ id ] = value.parse
      elseIf (_internal_property_map.contains(id))
        _internal_property_map.remove( id )
      endIf

    method get( String id ).PropertyValue
      if (_internal_property_map.contains(id))
        return _internal_property_map[id]
      else
        return null
      endIf

    method get( Int32 index ).PropertyValue
      return get(""+index)

    method as_Logical.Logical
      return count?

    method to_String( StringBuilder buffer, Logical strict_json )
      buffer.print( '{' )
      local var first = true
      forEach (key in _internal_property_map.keys)
        local var value = _internal_property_map[key]
        if (value isNot NullProperty)
          if (first) first = false
          else       buffer.print(',')
          if (strict_json)
            buffer.print('"')
            buffer.print(key)
            buffer.print('"')
            buffer.print(':')
            value.to_String( buffer, strict_json )
          else
            buffer.print(key)
            if (value.count? or value notInstanceOf PropertyTable)
              buffer.print(':')
              value.to_String( buffer, strict_json )
            endIf
          endIf
        endIf
      endForEach
      buffer.print( '}' )

endClass

class PropertyList : PropertyValue
  PROPERTIES
    _internal_property_list() : PropertyValue[]

  METHODS
    method init

    method init( String data )
      init( PropertyData(st) )

    method init( PropertyData data )
      init( ParseReader(data.data) )

    method init( ParseReader reader )
      reader.consume_ws
      reader.must_consume('[')

      reader.consume_ws
      if (not reader.consume(']'))

        local var first = true
        while (first or (not first and reader.consume(',')))
          first = false

          reader.consume_ws
          local var value = PropertyData.parse_value(reader)
          add( value )

          reader.consume_ws
        endWhile

        reader.must_consume(']')
      endIf

    method count.Int32
      return _internal_property_list.count

    method keys.Reader<<String>>
      local String[] result( count )
      forEach (n in 0..<count) result.add( ""+n )
      return result.create_reader

    method create_reader.Reader<<PropertyValue>>
      return _internal_property_list.create_reader

    method add( PropertyValue value ).PropertyList
      _internal_property_list.add( value )
      return this

    method add( String value ).PropertyList
      return add( StringProperty(value) )

    method add( Real64 value ).PropertyList
      return add( NumberProperty(value) )

    method add( PropertyData value ).PropertyList
      return add( value.parse )

    method set( Int32 index, PropertyValue value )
      _internal_property_list.ensure_count( index + 1 )
      _internal_property_list[index] = value

    method set( Int32 index, PropertyData value )
      set( index, value.parse )

    method set( Int32 index, String value )
      set( index, StringProperty(value) )

    method set( Int32 index, Real64 value )
      set( index, NumberProperty(value) )

    method get( String id ).PropertyValue
      return get( id.to_Int32 )

    method get( Int32 index ).PropertyValue
      if (index < 0 or index >= _internal_property_list.count)
        return null
      else
        local var result = _internal_property_list[index]
        if (result is null) return NullProperty
        return result
      endIf

    method as_Logical.Logical
      return count?

    method to_String( StringBuilder buffer, Logical strict_json )
      while (_internal_property_list.count? ...
          and _internal_property_list.last is NullProperty)
        _internal_property_list.remove_last
      endWhile

      buffer.print( '[' )
      local var first = true
      forEach (value in _internal_property_list)
        if (first) first = false
        else       buffer.print(',')
        if (value is null) buffer.print( "null" )
        else value.to_String( buffer, strict_json )
      endForEach
      buffer.print( ']' )
endClass

singleton class NullProperty : PropertyValue
  METHODS
    method to_String.String
      return "null"

    method as_Real64.Real64
      return 0.0

    method to_String( StringBuilder buffer, Logical strict_json )
      buffer.print( "null" )
endClass

singleton class TrueProperty : PropertyValue
  METHODS
    method to_String.String
      return "true"

    method as_Real64.Real64
      return 1.0

    method as_Logical.Logical
      return true

    method to_String( StringBuilder buffer, Logical strict_json )
      buffer.print( "true" )
endClass

singleton class FalseProperty : PropertyValue
  METHODS
    method to_String.String
      return "false"

    method as_Real64.Real64
      return 0.0

    method as_Logical.Logical
      return false

    method to_String( StringBuilder buffer, Logical strict_json )
      buffer.print( "false" )
endClass

class StringProperty( String value ) : PropertyValue
  METHODS
    method init( ParseReader reader )
      local StringBuilder buffer()

      reader.consume_ws
      reader.must_consume('"')
      while (not reader.consume('"'))
        local var ch = reader.read
        if (ch == '\\')
          which (reader.read)
            case '"':  buffer.print('"')
            case '\\': buffer.print('\\')
            case '/':  buffer.print('/')
            case 'b':  buffer.print(Char(8))
            case 'f':  buffer.print(Char(12))
            case 'n':  buffer.print(Char(10))
            case 'r':  buffer.print(Char(13))
            case 't':  buffer.print(Char(9))
            case 'u':
              local var n = 0
              forEach (1..4)
                n = n*16 + reader.read.to_value
              endForEach
              buffer.print( Char(n) )
          endWhich
        else
          buffer.print(ch)
        endIf
      endWhile

      value = buffer.to_String

    method is_String.Logical
      return true

    method as_String.String
      return value

    method to_String.String
      return value

    method as_Int64.Int64
      return value.to_Int64

    method to_String( StringBuilder buffer, Logical strict_json )
      buffer.print( '"' )
      forEach (ch in value)
        which (ch)
          case '"':  buffer.print("\\\"")
          case '\\': buffer.print("\\\\")
          case '/':  buffer.print("\\/")
          case   8:  buffer.print("\\b")
          case  12:  buffer.print("\\f")
          case  10:  buffer.print("\\n")
          case  13:  buffer.print("\\r")
          case   9:  buffer.print("\\t")
          others:
          if (ch >= 32 and ch <= 126) buffer.print(ch)
          else buffer.print( "\\u$(04)" (Int32(ch).to_String(16)) )
        endWhich
      endForEach
      buffer.print( '"' )
endClass

class NumberProperty( Real64 value ) : PropertyValue
  METHODS
    method init( ParseReader reader )
      local StringBuilder buffer()

      reader.consume_ws
      if (reader.consume('-')) buffer.print('-')
      while (reader.peek.is_digit(10)) buffer.print(reader.read)

      if (reader.consume('.'))
        buffer.print('.')
        while (reader.peek.is_digit(10)) buffer.print(reader.read)
      endIf

      if (reader.consume('e') or reader.consume('E'))
        buffer.print('e')
        if (reader.consume('-')) buffer.print('-')
        elseIf (reader.consume('+')) buffer.print('+')
        while (reader.peek.is_digit(10)) buffer.print(reader.read)
      endIf

      value = buffer.to_String.to_Real64

    method is_number.Logical
      return true

    method as_String.String
      return to_String

    method as_Real64.Real64
      return value

    method as_Int64.Int64
      return Int64(value)

    method op+( PropertyValue other ).PropertyValue
      if (other.is_String)
        return StringProperty( to_String + other.as_String )
      else
        return NumberProperty( value + other.as_Real64 )
      endIf

    method op+( Real64 other ).PropertyValue
      return NumberProperty( value + other )

    method to_String( StringBuilder buffer, Logical strict_json )
      if (value == infinity)
        buffer.print( "infinity" )
      elseIf (value == -infinity)
        buffer.print( "-infinity" )
      elseIf (value.is_NaN)
        buffer.print( "NaN" )
      elseIf (value == Int64(value))
        buffer.print( ""+Int64(value) )
      else
        local String st = "$(.8)" (value)
        forEach (1..7)
          if (st.last == '0') st = st.excluding_rightmost(1)
          else escapeForEach
        endForEach
        buffer.print( st )
      endIf


endClass

#==============================================================================
#  Runtime
#==============================================================================
requisite singleton class Runtime
  PROPERTIES
    types : HashTable<<String,RuntimeType>>

  METHODS
    method init
      if (types is null)
        # Order of initialization guard
        types = HashTable<<String,RuntimeType>>()
      endIf

    method get( String name ).RuntimeType
      if (not types.contains(name)) return null
      return types[name]

    method create( String name ).Object
      if (not types.contains(name)) return null
      return types[name].create_instance

    method set_up
endClass

abstract class RuntimeType
  PROPERTIES
    base_type_names() : String[]
      # A list of the direct and indirect base types of the
      # runtime type, including aspects and non-runtime classes.
      #
      # See also: base_types


  METHODS
    method init_object
      Runtime.init
      Runtime.types[name] = this

    method base_types.RuntimeType[]
      # Returns the a list of direct and indirect base types
      # that are also 'runtime' types.
      #
      # See also: base_type_names
      local RuntimeType[] result()
      forEach (name in base_type_names)
        local var base_type = Runtime[name]
        if (base_type?) result.add( base_type )
      endForEach
      return result

    method instance_of( String base_type_name ).Logical
      if (name == base_type_name) return true
      return base_type_names.contains(base_type_name)

    method instance_of( RuntimeType base_runtime_type ).Logical
      if (this is base_runtime_type) return true
      forEach (name in base_type_names)
        if (Runtime[name] is base_runtime_type) return true 
      endForEach
      return false

    abstract method create_instance.Object

    abstract method name.String
endClass

requisite class DelegateType;

requisite aspect HasDefaultInit
  # Added to 'runtime' types to make sure they have an empty init()
  # method.
  method init
endAspect

